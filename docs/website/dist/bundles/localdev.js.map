{"version":3,"file":"localdev.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACiE;AACV;AACM;AACH;AACmB;AACnB;AACU;AACF;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+DAAa;AAChE;AACA;AACA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAA8C,cAAc;AAC3F;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uFAAmB;AAC/B,6BAA6B,6EAAkB;AAC/C;AACA,2BAA2B,6EAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,QAAQ,sEAAoB;AAC5B,QAAQ,mEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAoB;AAC5B;AACA;AACA,0BAA0B,mBAAmB;AAC7C,2CAA2C,cAAc,aAAa;AACtE;AACA;AACA,0BAA0B,mBAAmB;AAC7C,2CAA2C,IAAI,cAAc,cAAc,aAAa;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAI,GAAG,0BAA0B;AACrC;AACA;AACA,IAAI,gEAAQ;AACZ;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,0EAAQ;AACZ;AACoB;;;;;;;;;;;;;;;;AC7IoC;AACxD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,eAAe,sEAAmB;AAClC;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtD0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM,IAAI;AAClC;AACA,iEAAiE,mEAAW,WAAW,IAAI,mEAAW;AACtG;AACA;AACA;AACA,+CAA+C;AAC/C;AACO,yBAAyB;AAChC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5B0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM,IAAI;AAClC;AACA,iEAAiE,mEAAW,WAAW,IAAI,mEAAW;AACtG;AACA;AACA;AACA,+CAA+C;AAC/C;AACO,6BAA6B;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrBoE;AACpE;AACA;AACA;AACA,eAAe,gEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM,IAAI;AAClC;AACA,iEAAiE,mEAAW,WAAW,IAAI,mEAAW;AACtG;AACA;AACA;AACA,+CAA+C;AAC/C;AACO,6BAA6B;AACpC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrCA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACgF;AACZ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0EAAQ;AACZ;AAC2B;AAC3B;AACA,6BAA6B,gGAA4B;AACzD;AACA,2BAA2B,wFAAoB;AAC/C,8BAA8B,2FAAuB;AACrD,gCAAgC,2FAAuB;AACvD,+BAA+B,4FAAwB;AACvD,2BAA2B,8FAA0B;AACrD;AACA,0BAA0B,uFAAmB;AAC7C,4BAA4B,6FAAyB;AACrD,6BAA6B,0FAAsB;AACnD,6BAA6B,0FAAsB;AACnD,8BAA8B,2FAAuB;AACrD,kCAAkC,iGAA6B;;;;;;;;;;;;;;;;;ACxD/D,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACoE;AACpE;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0EAAQ;AACZ;AACgC;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS,sBAAsB,SAAS;AACtE;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA,mBAAmB,UAAU,KAAK,UAAU,KAAK,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3FA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACoE;AACY;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wFAAoB;AAChE;AACA,YAAY,2FAAuB;AACnC,uDAAuD,IAAI;AAC3D,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0EAAQ;AACZ;AACwB;;;;;;;;;;;;;;;;ACtCxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;;;;;;;;;;;;;;;;AC5B2C;AAClD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA,YAAY,qDAAM;AAClB,oCAAoC,sDAAO,GAAG,kDAAG;AACjD,YAAY,yDAAU;AACtB,oCAAoC,kDAAG,GAAG,sDAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,MAAM;AAC/D;AACA;;;;;;;;;;;;;;;;;;AC7CoE;AAClB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0CAA0C,yDAAU;AACpD,mBAAmB,sDAAO;AAC1B,uDAAuD,qDAAM;AAC7D;AACA,mBAAmB,kDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0CAA0C,qDAAM;AAChD,mBAAmB,kDAAG;AACtB,uDAAuD,yDAAU;AACjE;AACA,mBAAmB,sDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjFA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AAC6D;AACI;AACd;AACe;AACT;AACI;AACY;AAC0B;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,uBAAuB,qFAAqB;AAC5C,SAAS;AACT,mBAAmB,qFAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAM;AAClB,4BAA4B,iEAAO,GAAG,6DAAG;AACzC,YAAY,oEAAU;AACtB,4BAA4B,6DAAG,GAAG,iEAAO;AACzC,mBAAmB,kFAAmB;AACtC;AACA;AACA;AACA,oBAAoB,6DAAG;AACvB;AACA,wBAAwB,iEAAO;AAC/B;AACA;AACA;AACA,IAAI,sEAAO;AACX;AACA;AACA,IAAI,0EAAQ;AACZ;AACyB;AACzB;AACA,kBAAkB,4DAAY;AAC9B,kBAAkB,2EAAoB;AACtC,kBAAkB,kEAAe;;;;;;;;;;;;;;;;;;;;AClGjC,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACiE;AACA;AACV;AACG;AACV;AAChD;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA,2EAA2E,sEAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAkB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yDAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,+DAAkB;AACzG;AACA;AACA;AACA;AACA,YAAY,mEAAW,4BAA4B,mEAAW;AAC9D;AACA,+BAA+B,4BAA4B;AAC3D;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA,0CAA0C,gEAAQ;AAClD;AACA,IAAI,0EAAQ;AACZ;AAC4B;;;;;;;;;;;;;;;;ACrHsB;AAClD;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACO;AACP;AACA,sBAAsB,kEAAiB;AACvC;AACA;AACA;AACA;AACA,kBAAkB,aAAa,KAAK,cAAc;AAClD;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACiE;AACY;AACjB;AACL;AACF;AACQ;AACH;AACI;AACI;AAClB;AAChD;AACA;AACA;AACA;AACA,iFAAiF,eAAe;AAChG;AACA,kEAAkE,kEAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU,yBAAyB;AAC5E;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA,wBAAwB,6EAAqB;AAC7C;AACA;AACA;AACA,8BAA8B,8DAAM,YAAY,MAAM;AACtD;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,yEAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wDAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA,gCAAgC,qDAAQ;AACxC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,QAAQ,qEAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA,YAAY,qEAAe;AAC3B,uCAAuC,GAAG;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,mEAAiB;AACzB;AACA;AACA;AACA;AACA,QAAQ,sEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAe;AAC3B;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAI,GAAG,2BAA2B;AACtC;AACA;AACA,IAAI,4DAAI,GAAG,oBAAoB,KAAK,QAAQ;AAC5C;AACA;AACA,IAAI,4DAAI,GAAG,kBAAkB;AAC7B;AACA;AACA,IAAI,4DAAI,GAAG,yBAAyB;AACpC;AACA;AACA,IAAI,4DAAI,GAAG,sBAAsB;AACjC;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI,GAAG,wBAAwB;AACnC;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB,oBAAoB;AACnD;AACA;AACA,IAAI,sEAAO;AACX;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,2EAAQ;AACZ;AACyB;;;;;;;;;;;;;;;;;;;;;;;;ACtSzB,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACiE;AACP;AACH;AACK;AACW;AACb;AACC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA,sCAAsC,+DAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAiB;AACzB,iCAAiC,qEAAe,OAAO,mEAAiB;AACxE;AACA;AACA;AACA;AACA,gDAAgD,4CAA4C;AAC5F;AACA,QAAQ,qEAAe;AACvB,oDAAoD,4CAA4C;AAChG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAoB;AAC5B,QAAQ,sEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAA+C;AAC9E;AACA;AACA;AACA;AACA,IAAI,4DAAI,GAAG,sBAAsB;AACjC;AACA;AACA,IAAI,4DAAI,GAAG,yBAAyB;AACpC;AACA;AACA,IAAI,4DAAI,GAAG,8BAA8B;AACzC;AACA;AACA,IAAI,4DAAI,GAAG,sBAAsB;AACjC;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB,kCAAkC;AACjE;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB;AAC/B;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,0EAAQ;AACZ;AACoB;;;;;;;;;;;;;;;;;AClJ4B;AAChD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7LA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACmD;AACc;AACM;AAChB;AACM;AACJ;AACF;AACmB;AAChB;AACV;AACG;AACe;AACP;AACD;AACsB;AAChF;AACA;AACA,wBAAwB;AACxB;AACA,qBAAqB,mEAAW;AAChC;AACA;AACA,sCAAsC,+DAAa;AACnD;AACA;AACA,uCAAuC,kEAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAqB;AACpC;AACA;AACA;AACA,gBAAgB,0EAAqB;AACrC;AACA;AACA;AACA;AACA,eAAe,8DAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,QAAQ,qEAAe,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wEAAa;AACrB,QAAQ,wEAAa;AACrB,QAAQ,wEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,2BAA2B,4DAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAS;AACrC,iBAAiB,6DAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,qDAAI;AACtF,4BAA4B,qDAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAS;AAC5B,mBAAmB,oEAAa;AAChC;AACA,gBAAgB,yBAAyB,EAAE,sEAAiB;AAC5D;AACA;AACA,6BAA6B,QAAQ;AACrC,4BAA4B,QAAQ;AACpC;AACA;AACA,oEAAoE,QAAQ;AAC5E,qEAAqE,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAI,GAAG,qBAAqB;AAChC;AACA;AACA,IAAI,6DAAI,GAAG,qBAAqB;AAChC;AACA;AACA,IAAI,iEAAQ;AACZ;AACA;AACA,IAAI,6DAAI,GAAG,mBAAmB;AAC9B;AACA;AACA,IAAI,6DAAI,GAAG,iBAAiB,qBAAqB,GAAG;AACpD;AACA;AACA,IAAI,iEAAQ,GAAG;AACf;AACA;AACA,WAAW;AACX;AACA;AACA,IAAI,iEAAI;AACR;AACA;AACA,IAAI,iEAAI;AACR;AACA;AACA,IAAI,+DAAK;AACT;AACA;AACA,IAAI,sEAAO;AACX;AACA;AACA,IAAI,sEAAO;AACX;AACA;AACA,IAAI,sEAAO;AACX;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,2EAAQ;AACZ;AACoB;;;;;;;;;;;;;;;;;;;;;;;;;;ACtTpB,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACiE;AACY;AACtB;AACE;AACA;AACD;AACQ;AACE;AACf;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kEAAc;AAC5D;AACA;AACA,6BAA6B,kEAAY;AACzC,gCAAgC,kEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6EAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe;AAChF,iEAAiE,eAAe;AAChF;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA,uEAAuE,eAAe;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4EAA4B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAc;AAC3C;AACA,eAAe,mEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD,sBAAsB,kFAA+B;AACrD;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iFAA8B;AACpD;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,QAAQ,0EAAuB;AAC/B,QAAQ,0EAAuB,oEAAoE,gBAAgB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,eAAe;AAC7E,QAAQ,0EAAuB;AAC/B,QAAQ,0EAAuB,uEAAuE,gBAAgB;AACtH;AACA;AACA;AACA,sBAAsB,iFAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAuB;AACnC;AACA;AACA;AACA,YAAY,0EAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yEAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAQ;AACZ;AACA;AACA,IAAI,gEAAQ;AACZ;AACA;AACA,IAAI,4DAAI,GAAG,0BAA0B;AACrC;AACA;AACA,IAAI,4DAAI,GAAG,iCAAiC;AAC5C;AACA;AACA,IAAI,4DAAI,GAAG,iCAAiC;AAC5C;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB;AAC/B;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB;AAC/B;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB;AAC/B;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB;AAC/B;AACA;AACA,IAAI,8DAAK;AACT;AACA;AACA,IAAI,8DAAK;AACT;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,2EAAQ;AACZ;AACwB;;;;;;;;;;;;;;;;;;AC7WxB,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACiE;AACb;AACU;AAC9D;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE,oBAAoB,qBAAqB,kDAAkD;AAC3F;AACA,kCAAkC,yDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uEAAI,GAAG,sBAAsB;AACjC;AACA;AACA,IAAI,uEAAI,GAAG,wBAAwB;AACnC;AACA;AACA,IAAI,0EAAQ;AACZ;AACkB;;;;;;;;;;;;;;;;;;;;;;;;;;AC9ClB,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACiE;AACE;AACV;AACF;AACM;AACV;AACO;AACA;AACwB;AAC/C;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB,oBAAoB,cAAc,aAAa,qBAAqB,cAAc;AAClF;AACA,gDAAgD,kEAAc;AAC9D;AACA;AACA,qCAAqC,mEAAQ;AAC7C,sCAAsC,mEAAQ;AAC9C;AACA,yBAAyB,kEAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6FAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2HAA2H,eAAe;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA,0CAA0C,+CAAS;AACnD;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAc,UAAU,mEAAmB;AAC1D;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B,8DAAc,UAAU,mEAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAc,UAAU,mEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAoB,UAAU,KAAK;AAC/C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAI,GAAG,0BAA0B;AACrC;AACA;AACA,IAAI,4DAAI,GAAG,oCAAoC;AAC/C;AACA;AACA,IAAI,sEAAO;AACX;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,2EAAQ;AACZ;AACmB;;;;;;;;;;;;;;;;;;;;ACjOnB,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC6D;AACN;AACC;AACS;AAChB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,kEAAc;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAiB;AACxC;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,0EAAQ;AACZ;AACmC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJnC,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACiE;AACL;AACF;AACH;AACgB;AACd;AACoB;AACZ;AACsB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kEAAc;AAChF;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oDAAoD;AAC7F;AACA;AACA;AACA,8BAA8B;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2FAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB,uEAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,+DAAO;AAChE;AACA,yDAAyD,+DAAO;AAChE;AACA;AACA;AACA;AACA;AACA,yDAAyD,+DAAO;AAChE;AACA,yDAAyD,+DAAO;AAChE;AACA;AACA,gEAAgE,mBAAmB;AACnF;AACA;AACA;AACA,4DAA4D,UAAU,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU,QAAQ,qBAAqB;AACzE;AACA,gEAAgE,mBAAmB;AACnF;AACA;AACA;AACA,4DAA4D,UAAU,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU,QAAQ,qBAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAiB;AACzB,QAAQ,mEAAiB;AACzB;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAoB;AAC5B,QAAQ,sEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uCAAuC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qEAAoB;AACnE;AACA;AACA;AACA;AACA,wBAAwB,iDAAiD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAoD;AACxE;AACA;AACA,yCAAyC,oDAAG;AAC5C,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAI;AACR;AACA;AACA,IAAI,4DAAI,GAAG,sBAAsB;AACjC;AACA;AACA,IAAI,4DAAI,GAAG,eAAe;AAC1B;AACA;AACA,IAAI,4DAAI,GAAG,kBAAkB;AAC7B;AACA;AACA,IAAI,gEAAQ;AACZ;AACA;AACA,IAAI,gEAAQ;AACZ;AACA;AACA,IAAI,gEAAQ;AACZ;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB,kCAAkC;AACjE;AACA;AACA,IAAI,gEAAQ,GAAG,kBAAkB;AACjC;AACA;AACA,IAAI,gEAAQ,GAAG,kBAAkB;AACjC;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,2EAAQ;AACZ;AACyB;;;;;;;;;;;;;;;;;;;AChTzB,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACiE;AACF;AACC;AACuC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAAiB;AACrC;AACA;AACA,eAAe,2DAAI;AACnB;AACA;AACA,oBAAoB,yEAAiB;AACrC;AACA;AACA,eAAe,2DAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAK;AAChD;AACA,qDAAqD,uBAAuB;AAC5E;AACA;AACA;AACA,6DAA6D,uBAAuB;AACpF;AACA;AACA;AACA;AACA;AACA,cAAc,8DAAO;AACrB,cAAc,+DAAQ;AACtB,cAAc,+DAAQ;AACtB,eAAe,mEAAY;AAC3B,gBAAgB,iEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAI;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,0EAAQ;AACZ;AAC2B;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrH3B,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACiE;AACY;AACtB;AACE;AACC;AACA;AACF;AACU;AACW;AAClB;AAC3D,0CAA0C,kEAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2FAAuB,IAAI,uEAAiB;AAC3D;AACA;AACA;AACA,eAAe,uEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6EAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;AACA,mBAAmB,mEAAW;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,mBAAmB,mEAAW;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6EAAqB;AAC/C,qBAAqB,sEAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA,yCAAyC,OAAO;AAChD;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,cAAc,sDAAK,EAAE,sDAAK;AAC1B;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA,yCAAyC,OAAO;AAChD;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAW;AACjC,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAW;AACjC,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAQ,GAAG,gBAAgB;AAC/B;AACA;AACA,IAAI,4DAAI,GAAG,kBAAkB;AAC7B;AACA;AACA,IAAI,4DAAI,GAAG,kBAAkB;AAC7B;AACA;AACA,IAAI,4DAAI,GAAG,yBAAyB;AACpC;AACA;AACA,IAAI,4DAAI,GAAG,wBAAwB;AACnC;AACA;AACA,IAAI,4DAAI,GAAG,wBAAwB;AACnC;AACA;AACA,IAAI,4DAAI,GAAG,qBAAqB;AAChC;AACA;AACA,IAAI,4DAAI,GAAG,yBAAyB;AACpC;AACA;AACA,IAAI,4DAAI,GAAG,kBAAkB;AAC7B;AACA;AACA,IAAI,4DAAI,GAAG,sBAAsB;AACjC;AACA;AACA,IAAI,4DAAI,GAAG,sBAAsB;AACjC;AACA;AACA,IAAI,4DAAI,GAAG,mBAAmB;AAC9B;AACA;AACA,IAAI,4DAAI,GAAG,mBAAmB;AAC9B;AACA;AACA,IAAI,8DAAK;AACT;AACA;AACA,IAAI,8DAAK;AACT;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,6DAAI;AACR;AACA;AACA,IAAI,2EAAQ;AACZ;AACsB;;;;;;;;;;;;;;;AC/QtB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;ACxB2C;AAC3C;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,+BAA+B,wDAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;;ACxC+D;AACK;AACpE;AACA;AACA;AACA;AACO,0BAA0B,4DAAiB;AAClD;AACA;AACA;AACA;AACA,YAAY,yDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,wDAAS;AACjF,4EAA4E,wDAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,uCAAuC,2CAA2C;AAClF,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;ACxB+C;AAC/C;AACO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAe;AACvB;AACA;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1BqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAI,wBAAwB,QAAQ,4FAA4F;AAC5I;AACA;AACA,YAAY,iDAAI;AAChB;AACA;AACA;;;;;;;;;;;;;;;ACjGO;AACP;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClBP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzFA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACgD;AAChD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;ACxD4C;AACO;AACnD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAa;AAC/D;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8CAA8C,iDAAW;AACzD;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAa;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wDAAQ,kBAAkB;AACrC;;;;;;;;;;;;;;;;;;;;;;;AClHA;AACO;AACP;AACA;AACA;AACO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnD8B;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,4CAAS;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACuC;AACvC,QAAQ,8BAA8B;AACtC;AACO;AACA;AACP;AACO;AACA;AACA;AACP;AACO;AACA;AACP;AACO;AACA;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oDAAQ;AACZ;AAC0B;;;;;;;;;;;;;;;;ACnG1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO,KAAK,KAAK;AAC/D;AACA,yCAAyC;AACzC,KAAK;AACL;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;;;;;;;;;;;;;;;AC5CA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACNuC;AACA;AACvC;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,oDAAW;AACtB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,gDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;;;;;;;;;;;;;;;;;;;;;;;;AC9C+B;AAC/B;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AACvE,6BAA6B,EAAE,cAAc,GAAG;AACvD,eAAe,IAAI;AACZ;AACP;AACA,oBAAoB,4CAAG;AACvB;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC/DA;AACO;AACP;AACO;;;;;;;;;;;;;;;;ACHP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrCA;AACO;AACP;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mCAAmC,WAAW;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,IAAI;AACT;;;;;;;;;;;;;;;;;AC3HA,qBAAqB,qBAAM;AAC3B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACO;;;;;;;;;;;;;;;;ACnB2B;;;;;;;;;;;;;;;;;;;;;ACAlC,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AAC8E;AACb;AAC1D,6BAA6B,sDAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAiB;AACzB;AACA;AACA;AACA,QAAQ,6DAAiB;AACzB;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAAiB;AAC3C;AACA,iDAAiD,iDAAiD;AAClG;AACA;AACA,qDAAqD,iBAAiB;AACtE;AACA;AACA;AACA;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAAiB;AAC3C;AACA,iDAAiD,2DAA2D;AAC5G;AACA;AACA,YAAY,6DAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iDAAI;AACR;AACA;AACA,IAAI,iDAAI;AACR;AACA;AACA,IAAI,iDAAI;AACR;AACA;AACA,IAAI,iDAAI;AACR;AACA;AACA,IAAI,+EAAI,GAAG,mBAAmB;AAC9B;AACA;AACA,IAAI,8CAAK;AACT;AACA;AACA,IAAI,6CAAI;AACR;AACA;AACA,IAAI,6CAAI;AACR;;;;;;;UCpGA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;ACIqB;AACoC;AACzD;AACA,2EAAuB;AACvB;AACA,yDAAgB;AAChB,wDAAe;AACf;AACA,qEAA4B;AAC5B,0DAAiB;AACjB;AACA,+DAAsB;AACtB,0DAAiB;AACjB;AACA,4DAAmB;AACnB;AACA,8DAAqB;AACrB;AACA,sDAAa;AACb;AACA,CAAC","sources":["webpack://AEK/./node_modules/@exadel/esl/modules/esl-alert/core/esl-alert.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-base-element/core/esl-base-element.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-base-element/decorators/attr.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-base-element/decorators/bool-attr.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-base-element/decorators/json-attr.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/common/env-shortcuts.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/common/screen-breakpoint.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/common/screen-dpr.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/conditions/media-query-base.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/conditions/media-query-condition.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/conditions/media-query-containers.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/esl-media-query.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/esl-media-rule-list.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-media-query/core/esl-media-rule.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-panel-group/core/esl-panel-group.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-panel/core/esl-panel.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-popup/core/esl-popup-position.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-popup/core/esl-popup.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-scrollbar/core/esl-scrollbar.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-tab/core/esl-tab.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-tab/core/esl-tabs.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-toggleable/core/esl-toggleable-dispatcher.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-toggleable/core/esl-toggleable.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-traversing-query/core/esl-traversing-query.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-trigger/core/esl-trigger.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/abstract/observable.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/async/debounce.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/async/delayed-task.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/async/promise.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/async/raf.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/decorators/bind.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/decorators/memoize.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/decorators/prop.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/decorators/ready.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/api.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/class.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/events.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/keys.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/ready.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/rect.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/rtl.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/scroll.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/traversing.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/dom/window.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/environment/device-detector.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/environment/export-ns.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/fixes/ie-fixes.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/misc/array.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/misc/format.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/misc/functions.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/misc/memoize.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/misc/object.js","webpack://AEK/./node_modules/@exadel/esl/modules/esl-utils/misc/uid.js","webpack://AEK/./src/navigation/navigation.ts","webpack://AEK/./src/navigation/sidebar/sidebar.ts","webpack://AEK/webpack/bootstrap","webpack://AEK/webpack/runtime/define property getters","webpack://AEK/webpack/runtime/global","webpack://AEK/webpack/runtime/hasOwnProperty shorthand","webpack://AEK/webpack/runtime/make namespace object","webpack://AEK/./src/localdev.js"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ESLAlert_1;\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { attr, jsonAttr } from '../../esl-base-element/core';\nimport { ESLToggleable } from '../../esl-toggleable/core';\nimport { DeviceDetector } from '../../esl-utils/environment/device-detector';\nimport { CSSClassUtils } from '../../esl-utils/dom/class';\nimport { createZIndexIframe } from '../../esl-utils/fixes/ie-fixes';\nimport { TraversingQuery } from '../../esl-traversing-query/core';\n/**\n * ESLAlert component\n *\n * @author Julia Murashko\n *\n * ESLAlert is a component to show small notifications on your pages. ESLAlert can have multiple instances on the page.\n */\nlet ESLAlert = ESLAlert_1 = class ESLAlert extends ESLToggleable {\n    static get observedAttributes() {\n        return ['target'];\n    }\n    /** Creates global alert instance (using body element as a base) */\n    static init(options) {\n        let alert = document.querySelector(`body > ${ESLAlert_1.is}`);\n        if (!alert) {\n            alert = document.createElement(ESLAlert_1.is);\n            options && Object.assign(alert, options);\n            document.body.appendChild(alert);\n        }\n        return alert;\n    }\n    mergeDefaultParams(params) {\n        const type = this.constructor;\n        return Object.assign({}, type.defaultConfig, this.defaultParams || {}, params || {});\n    }\n    attributeChangedCallback(attrName, oldVal, newVal) {\n        if (!this.connected)\n            return;\n        if (attrName === 'target') {\n            this.$target = TraversingQuery.first(this.target);\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute('role', this.getAttribute('role') || 'alert');\n        this.$content = document.createElement('div');\n        this.$content.className = 'esl-alert-content';\n        this.innerHTML = '';\n        this.appendChild(this.$content);\n        if (DeviceDetector.isIE)\n            this.appendChild(createZIndexIframe());\n        if (this.target) {\n            this.$target = TraversingQuery.first(this.target, this);\n        }\n    }\n    unbindEvents() {\n        super.unbindEvents();\n        this.unbindTargetEvents();\n    }\n    /** Target element to listen to activation events */\n    get $target() {\n        return this._$target;\n    }\n    set $target($el) {\n        this.unbindTargetEvents();\n        this._$target = $el;\n        this.bindTargetEvents();\n    }\n    bindTargetEvents() {\n        if (!this.$target || !this.connected)\n            return;\n        this.$target.addEventListener(`${ESLAlert_1.eventNs}:show`, this._onTargetEvent);\n        this.$target.addEventListener(`${ESLAlert_1.eventNs}:hide`, this._onTargetEvent);\n    }\n    unbindTargetEvents() {\n        if (!this.$target)\n            return;\n        this.$target.removeEventListener(`${ESLAlert_1.eventNs}:show`, this._onTargetEvent);\n        this.$target.removeEventListener(`${ESLAlert_1.eventNs}:hide`, this._onTargetEvent);\n    }\n    onShow(params) {\n        if (this._clearTimeout)\n            window.clearTimeout(this._clearTimeout);\n        if (params.html || params.text) {\n            this.render(params);\n            super.onShow(params);\n        }\n        this.hide(params);\n    }\n    onHide(params) {\n        super.onHide(params);\n        this._clearTimeout = window.setTimeout(() => this.clear(), params.hideTime);\n    }\n    render({ text, html, cls }) {\n        CSSClassUtils.remove(this, this.activeCls);\n        CSSClassUtils.add(this, this.activeCls = cls);\n        if (html)\n            this.$content.innerHTML = html;\n        if (text)\n            this.$content.textContent = text;\n    }\n    clear() {\n        this.$content.innerHTML = '';\n        CSSClassUtils.remove(this, this.activeCls);\n    }\n    _onTargetEvent(e) {\n        if (e.type === `${ESLAlert_1.eventNs}:show`) {\n            const params = Object.assign({}, e.detail, { force: true });\n            this.show(params);\n        }\n        if (e.type === `${ESLAlert_1.eventNs}:hide`) {\n            const params = Object.assign({}, { hideDelay: 0 }, e.detail, { force: true });\n            this.hide(params);\n        }\n        e.stopPropagation();\n    }\n};\nESLAlert.is = 'esl-alert';\nESLAlert.eventNs = 'esl:alert';\n/** Default show/hide params for all ESLAlert instances */\nESLAlert.defaultConfig = {\n    hideTime: 300,\n    hideDelay: 2500\n};\n__decorate([\n    attr({ defaultValue: '::parent' })\n], ESLAlert.prototype, \"target\", void 0);\n__decorate([\n    jsonAttr()\n], ESLAlert.prototype, \"defaultParams\", void 0);\n__decorate([\n    bind\n], ESLAlert.prototype, \"_onTargetEvent\", null);\nESLAlert = ESLAlert_1 = __decorate([\n    ExportNs('Alert')\n], ESLAlert);\nexport { ESLAlert };\n","import { EventUtils } from '../../esl-utils/dom/events';\n/**\n * Base class for ESL custom elements.\n * Allows to define custom element with the optional custom tag name.\n */\nexport class ESLBaseElement extends HTMLElement {\n    constructor() {\n        super(...arguments);\n        this._connected = false;\n    }\n    connectedCallback() {\n        this._connected = true;\n        this.classList.add(this.constructor.is);\n    }\n    disconnectedCallback() {\n        this._connected = false;\n    }\n    /** Check that the element is connected and `connectedCallback` has been executed */\n    get connected() {\n        return this._connected;\n    }\n    /**\n     * Dispatch component custom event.\n     * Uses 'esl:' prefix for event name, overridable to customize event namespaces.\n     * @param eventName - event name\n     * @param eventInit - custom event init. See {@link CustomEventInit}\n     */\n    $$fire(eventName, eventInit) {\n        return EventUtils.dispatch(this, 'esl:' + eventName, eventInit);\n    }\n    /**\n     * Register component in the {@link customElements} registry\n     * @param tagName - custom tag name to register custom element\n     */\n    static register(tagName) {\n        tagName = tagName || this.is;\n        if (!tagName)\n            throw new Error('Can not define custom element');\n        const constructor = customElements.get(tagName);\n        if (constructor) {\n            if (constructor.is !== tagName)\n                throw new Error('Element declaration tag inconsistency');\n            return;\n        }\n        if (this.is !== tagName) {\n            this.is = tagName;\n        }\n        customElements.define(tagName, this);\n    }\n    static get registered() {\n        return customElements.whenDefined(this.is);\n    }\n}\n/** Custom element tag name */\nESLBaseElement.is = '';\n","import { toKebabCase } from '../../esl-utils/misc/format';\nfunction buildSimpleDescriptor(attrName, readOnly, defaultValue) {\n    function get() {\n        const value = this.getAttribute(attrName);\n        return typeof value === 'string' ? value : defaultValue;\n    }\n    function set(value) {\n        if (value === undefined || value === null || value === false) {\n            this.removeAttribute(attrName);\n        }\n        else {\n            this.setAttribute(attrName, value === true ? '' : value);\n        }\n    }\n    return readOnly ? { get } : { get, set };\n}\nconst buildAttrName = (propName, dataAttr) => dataAttr ? `data-${toKebabCase(propName)}` : toKebabCase(propName);\n/**\n * Decorator to map current property to element attribute value.\n * Maps string type property.\n * @param config - mapping configuration. See {@link AttrDescriptor}\n */\nexport const attr = (config = {}) => {\n    config = Object.assign({ defaultValue: '' }, config);\n    return (target, propName) => {\n        const attrName = buildAttrName(config.name || propName, !!config.dataAttr);\n        Object.defineProperty(target, propName, buildSimpleDescriptor(attrName, !!config.readonly, config.defaultValue));\n    };\n};\n","import { toKebabCase } from '../../esl-utils/misc/format';\nfunction buildConditionalDescriptor(attrName, readOnly) {\n    function get() {\n        return this.hasAttribute(attrName);\n    }\n    function set(value) {\n        this.toggleAttribute(attrName, value);\n    }\n    return readOnly ? { get } : { get, set };\n}\nconst buildAttrName = (propName, dataAttr) => dataAttr ? `data-${toKebabCase(propName)}` : toKebabCase(propName);\n/**\n * Decorator to map current property to element boolean (marker) attribute state.\n * Maps boolean type property.\n * @param config - mapping configuration. See {@link BoolAttrDescriptor}\n */\nexport const boolAttr = (config = {}) => {\n    return (target, propName) => {\n        const attrName = buildAttrName(config.name || propName, !!config.dataAttr);\n        Object.defineProperty(target, propName, buildConditionalDescriptor(attrName, !!config.readonly));\n    };\n};\n","import { toKebabCase, evaluate } from '../../esl-utils/misc/format';\nfunction buildJsonAttrDescriptor(attrName, readOnly, defaultValue) {\n    function get() {\n        const attrContent = (this.getAttribute(attrName) || '').trim();\n        return evaluate(attrContent, defaultValue);\n    }\n    function set(value) {\n        if (typeof value !== 'object') {\n            console.error('Can not set json value: value should be object');\n        }\n        try {\n            if (value) {\n                const serializedValue = JSON.stringify(value);\n                this.setAttribute(attrName, serializedValue);\n            }\n            else {\n                this.removeAttribute(attrName);\n            }\n        }\n        catch (e) {\n            console.error('[ESL] jsonAttr: Can not set json value ', e);\n        }\n    }\n    return readOnly ? { get } : { get, set };\n}\nconst buildAttrName = (propName, dataAttr) => dataAttr ? `data-${toKebabCase(propName)}` : toKebabCase(propName);\n/**\n * Decorator to map current property to element attribute value using JSON (de-)serialization rules.\n * Maps object type property.\n * @param config - mapping configuration. See {@link JsonAttrDescriptor}\n */\nexport const jsonAttr = (config = {}) => {\n    config = Object.assign({ defaultValue: {} }, config);\n    return (target, propName) => {\n        const attrName = buildAttrName(config.name || propName, !!config.dataAttr);\n        Object.defineProperty(target, propName, buildJsonAttrDescriptor(attrName, !!config.readonly, config.defaultValue));\n    };\n};\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { DeviceDetector } from '../../../esl-utils/environment/device-detector';\nimport { ExportNs } from '../../../esl-utils/environment/export-ns';\nconst shortcuts = new Map();\n/**\n * Static shortcuts preprocessor. Used to store device related shortcuts.\n * @author Alexey Stsefanovich (ala'n)\n *\n * @implements IMediaQueryPreprocessor statically\n */\nlet ESLEnvShortcuts = class ESLEnvShortcuts {\n    /**\n     * Add mapping\n     * @param shortcut - term to find in query\n     * @param value - media query string or boolean result (that represents `all` or `not all` conditions)\n     */\n    static add(shortcut, value) {\n        if (!['boolean', 'string'].includes(typeof value))\n            value = false;\n        shortcuts.set(shortcut.toLowerCase(), value);\n    }\n    /** Remove mapping for passed shortcut term */\n    static remove(shortcut) {\n        return shortcuts.delete(shortcut.toLowerCase());\n    }\n    /** Replaces shortcut to registered result */\n    static process(match) {\n        if (shortcuts.has(match))\n            return shortcuts.get(match);\n    }\n};\n// For debug purposes\nESLEnvShortcuts._shortcuts = shortcuts;\nESLEnvShortcuts = __decorate([\n    ExportNs('EnvShortcuts')\n], ESLEnvShortcuts);\nexport { ESLEnvShortcuts };\n// Touch check\nESLEnvShortcuts.add('touch', DeviceDetector.isTouchDevice);\n// Basic device type shortcuts\nESLEnvShortcuts.add('bot', DeviceDetector.isBot);\nESLEnvShortcuts.add('mobile', DeviceDetector.isMobile);\nESLEnvShortcuts.add('desktop', !DeviceDetector.isMobile);\nESLEnvShortcuts.add('android', DeviceDetector.isAndroid);\nESLEnvShortcuts.add('ios', DeviceDetector.isMobileIOS);\n// Basic browser shortcuts\nESLEnvShortcuts.add('ie', DeviceDetector.isIE);\nESLEnvShortcuts.add('edge', DeviceDetector.isEdgeHTML);\nESLEnvShortcuts.add('gecko', DeviceDetector.isGecko);\nESLEnvShortcuts.add('blink', DeviceDetector.isBlink);\nESLEnvShortcuts.add('safari', DeviceDetector.isSafari);\nESLEnvShortcuts.add('safari-ios', DeviceDetector.isMobileSafari);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ESLScreenBreakpoints_1;\nimport { ExportNs } from '../../../esl-utils/environment/export-ns';\nconst registry = new Map();\n/**\n * ESL Screen Breakpoints registry\n * @author Yuliya Adamskaya, Alexey Stsefanovich (ala'n)\n *\n * Screen Breakpoint registry is used to provide custom breakpoints for {@link ESLMediaQuery}\n *\n * @implements IMediaQueryPreprocessor statically\n */\nlet ESLScreenBreakpoints = ESLScreenBreakpoints_1 = class ESLScreenBreakpoints {\n    /**\n     * Add or replace breakpoint shortcut that can be used inside ESLMediaQuery\n     * @param name - name of shortcut\n     * @param minWidth - min width for breakpoint\n     * @param maxWidth - max width for breakpoint\n     */\n    static add(name, minWidth, maxWidth) {\n        name = name.toLowerCase();\n        if (ESLScreenBreakpoints_1.BP_NAME_REGEXP.test(name)) {\n            const current = registry.get(name);\n            registry.set(name, new ESLScreenBreakpoint(name, minWidth, maxWidth));\n            return current;\n        }\n        throw new Error('The shortcut should consist only of Latin characters and be at least one character long.');\n    }\n    /** Removes screen breakpoint */\n    static remove(name) {\n        return registry.delete(name.toLowerCase());\n    }\n    /** @returns known breakpoint shortcut instance */\n    static get(name) {\n        return registry.get((name || '').toLowerCase());\n    }\n    /** All available breakpoints names */\n    static get names() {\n        const keys = [];\n        registry.forEach((value, key) => keys.push(key));\n        return keys;\n    }\n    /** @returns breakpoints shortcut replacement */\n    static process(term) {\n        const [, sign, bp] = term.match(ESLScreenBreakpoints_1.BP_REGEXP) || [];\n        const shortcut = ESLScreenBreakpoints_1.get(bp);\n        if (!shortcut)\n            return;\n        if (sign === '+')\n            return shortcut.mediaQueryGE;\n        if (sign === '-')\n            return shortcut.mediaQueryLE;\n        return shortcut.mediaQuery;\n    }\n};\nESLScreenBreakpoints.BP_REGEXP = /^([+-]?)([a-z]+)/i;\nESLScreenBreakpoints.BP_NAME_REGEXP = /^[a-z]+/i;\nESLScreenBreakpoints = ESLScreenBreakpoints_1 = __decorate([\n    ExportNs('ScreenBreakpoints')\n], ESLScreenBreakpoints);\nexport { ESLScreenBreakpoints };\n/** ESL Screen Breakpoint description */\nexport class ESLScreenBreakpoint {\n    constructor(name, min, max) {\n        this.name = name;\n        this.min = min;\n        this.max = max;\n    }\n    get mediaQuery() {\n        return `(min-width: ${this.min}px) and (max-width: ${this.max}px)`;\n    }\n    get mediaQueryGE() {\n        return `(min-width: ${this.min}px)`;\n    }\n    get mediaQueryLE() {\n        return `(max-width: ${this.max}px)`;\n    }\n    toString() {\n        return `[${this.name}]: ${this.min} to ${this.max}`;\n    }\n}\n// Defaults\nESLScreenBreakpoints.add('xs', 1, 767);\nESLScreenBreakpoints.add('sm', 768, 991);\nESLScreenBreakpoints.add('md', 992, 1199);\nESLScreenBreakpoints.add('lg', 1200, 1599);\nESLScreenBreakpoints.add('xl', 1600, 999999);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ESLScreenDPR_1;\nimport { ExportNs } from '../../../esl-utils/environment/export-ns';\nimport { DeviceDetector } from '../../../esl-utils/environment/device-detector';\n/**\n * DPR preprocessor. Used to replace DPR shortcuts.\n * @author Alexey Stsefanovich (ala'n)\n *\n * @implements IMediaQueryPreprocessor statically\n */\nlet ESLScreenDPR = ESLScreenDPR_1 = class ESLScreenDPR {\n    static toDPI(dpr) {\n        return (96 * dpr).toFixed(1);\n    }\n    static process(match) {\n        if (!ESLScreenDPR_1.VALUE_REGEXP.test(match))\n            return;\n        const dpr = parseFloat(match);\n        if (dpr < 0 || isNaN(dpr))\n            return;\n        if (ESLScreenDPR_1.ignoreBotsDpr && DeviceDetector.isBot && dpr > 1)\n            return 'not all';\n        if (DeviceDetector.isSafari)\n            return `(-webkit-min-device-pixel-ratio: ${dpr})`;\n        return `(min-resolution: ${ESLScreenDPR_1.toDPI(dpr)}dpi)`;\n    }\n};\nESLScreenDPR.VALUE_REGEXP = /(\\d(\\.\\d)?)x/;\n/** Option to exclude dpr greater then 2 for bots */\nESLScreenDPR.ignoreBotsDpr = false;\nESLScreenDPR = ESLScreenDPR_1 = __decorate([\n    ExportNs('ScreenDPR')\n], ESLScreenDPR);\nexport { ESLScreenDPR };\n","/**\n * Const media condition implementation\n * @author Alexey Stsefanovich (ala'n)\n *\n * Ignores listeners always return the same result.\n * Have only two instances: {@link ALL} and {@link NOT_ALL}\n */\nclass MediaQueryConstCondition {\n    constructor(_matches) {\n        this._matches = _matches;\n    }\n    get matches() {\n        return this._matches;\n    }\n    addListener(cb) { }\n    removeListener(cb) { }\n    optimize() {\n        return this;\n    }\n    toString() {\n        return this._matches ? 'all' : 'not all';\n    }\n    /** Compare const media condition with the passed query instance or string */\n    eq(val) {\n        return val.toString().trim() === this.toString();\n    }\n}\nexport const ALL = new MediaQueryConstCondition(true);\nexport const NOT_ALL = new MediaQueryConstCondition(false);\n","import { ALL, NOT_ALL } from './media-query-base';\n/**\n * Simple media condition implementation\n * @author Alexey Stsefanovich (ala'n)\n *\n * Wraps matchMedia instance\n */\nexport class MediaQueryCondition {\n    constructor(query, inverted = false) {\n        this._inverted = inverted;\n        this._mq = matchMedia(query.trim() || 'all');\n    }\n    get matches() {\n        return this._inverted ? !this._mq.matches : this._mq.matches;\n    }\n    addListener(listener) {\n        if (typeof this._mq.addEventListener === 'function') {\n            this._mq.addEventListener('change', listener);\n        }\n        else {\n            this._mq.addListener(listener);\n        }\n    }\n    removeListener(listener) {\n        if (typeof this._mq.removeEventListener === 'function') {\n            this._mq.removeEventListener('change', listener);\n        }\n        else {\n            this._mq.removeListener(listener);\n        }\n    }\n    /** Optimize query. Can simplify query to {@link MediaQueryConstCondition} */\n    optimize() {\n        if (ALL.eq(this))\n            return this._inverted ? NOT_ALL : ALL;\n        if (NOT_ALL.eq(this))\n            return this._inverted ? ALL : NOT_ALL;\n        return this;\n    }\n    toString() {\n        const query = this._mq.media;\n        const inverted = this._inverted;\n        const complex = inverted && /\\)[\\s\\w]+\\(/.test(query);\n        return (inverted ? 'not ' : '') + (complex ? `(${query})` : query);\n    }\n}\n","import { Observable } from '../../../esl-utils/abstract/observable';\nimport { ALL, NOT_ALL } from './media-query-base';\n/**\n * Abstract multiple media conditions container\n * @author Alexey Stsefanovich (ala'n)\n *\n * Observe all child items. Dispatch changes when the whole condition result is changed\n */\nclass MediaQueryContainer extends Observable {\n    constructor(items = []) {\n        super();\n        this.items = items;\n        this._matches = this.matches;\n        this._onChildChange = this._onChildChange.bind(this);\n    }\n    addListener(listener) {\n        super.addListener(listener);\n        if (this._listeners.size > 1)\n            return;\n        this.items.forEach((item) => item.addListener(this._onChildChange));\n    }\n    removeListener(listener) {\n        super.removeListener(listener);\n        if (this._listeners.size)\n            return;\n        this.items.forEach((item) => item.removeListener(this._onChildChange));\n    }\n    get matches() {\n        return false;\n    }\n    /** Exclude const conditions. Unwrap empty or trivial (with one item) containers */\n    optimize() {\n        return this;\n    }\n    /** Handle query change and dispatch it on top level in case result value is changed */\n    _onChildChange() {\n        const { matches } = this;\n        if (this._matches === matches)\n            return;\n        this.fire(this._matches = matches);\n    }\n}\n/** Conjunction (AND) group of media conditions */\nexport class MediaQueryConjunction extends MediaQueryContainer {\n    get matches() {\n        return this.items.every((item) => item.matches);\n    }\n    optimize() {\n        const optimizedItems = this.items.map((item) => item.optimize());\n        if (optimizedItems.some((item) => NOT_ALL.eq(item)))\n            return NOT_ALL;\n        const items = optimizedItems.filter((item) => !ALL.eq(item));\n        if (items.length === 0)\n            return ALL;\n        if (items.length === 1)\n            return items[0];\n        return new MediaQueryConjunction(items);\n    }\n    toString() {\n        return this.items.join(' and ');\n    }\n}\n/** Disjunction (OR) group of media conditions */\nexport class MediaQueryDisjunction extends MediaQueryContainer {\n    get matches() {\n        return this.items.some((item) => item.matches);\n    }\n    optimize() {\n        const optimizedItems = this.items.map((item) => item.optimize());\n        if (optimizedItems.some((item) => ALL.eq(item)))\n            return ALL;\n        const items = optimizedItems.filter((item) => !NOT_ALL.eq(item));\n        if (items.length === 0)\n            return NOT_ALL;\n        if (items.length === 1)\n            return items[0];\n        return new MediaQueryDisjunction(items);\n    }\n    toString(pretty = false) {\n        return this.items.join(pretty ? ' or ' : ', ');\n    }\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ESLMediaQuery_1;\nimport { memoize } from '../../esl-utils/decorators/memoize';\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { ESLScreenDPR } from './common/screen-dpr';\nimport { ESLScreenBreakpoints } from './common/screen-breakpoint';\nimport { ESLEnvShortcuts } from './common/env-shortcuts';\nimport { ALL, NOT_ALL } from './conditions/media-query-base';\nimport { MediaQueryCondition } from './conditions/media-query-condition';\nimport { MediaQueryConjunction, MediaQueryDisjunction } from './conditions/media-query-containers';\n/**\n * ESL Media Query\n * Provides special media condition syntax - ESLMediaQuery\n * @author Alexey Stsefanovich (ala'n), Yuliya Adamskaya, Natallia Harshunova\n *\n * Utility to support extended MediaQuery features\n * Supports\n * - CSS MediaQuery matching check\n * - DPR display queries (`@x1|@x2|@x3`)\n * - Registered screen default sizes (breakpoints) shortcuts (`@[-|+](XS|SM|MD|LG|XL)`)\n * - Device and browser shortcuts (`@MOBILE|@DESKTOP|@IE`)\n * - Custom static shortcuts and custom query preprocessors\n * - `not` logic operation (can have multiple not operators before any term of the query)\n * - `or` or `,` logical operator (have a lowest priority)\n * - Query matching change listeners\n *\n * Building query process:\n *\n * [Building query logical tree] - [preprocess nodes queries] - [building native MediaQueryList nodes] - [query tree optimization]\n */\nlet ESLMediaQuery = ESLMediaQuery_1 = class ESLMediaQuery {\n    /** Add {@link IMediaQueryPreprocessor} instance for query preprocessing step */\n    static use(preprocessor) {\n        this._preprocessors.unshift(preprocessor);\n        return this;\n    }\n    /** Cached method to create {@link ESLMediaQuery} condition instance from query string */\n    static for(query) {\n        return ESLMediaQuery_1.from(query);\n    }\n    /** Creates {@link ESLMediaQuery} condition instance from query string */\n    static from(query) {\n        const conjunctions = query.split(/\\sor\\s|,/).map((term) => {\n            const conditions = term.split(/\\sand\\s/).map(ESLMediaQuery_1.parseSimpleQuery);\n            return new MediaQueryConjunction(conditions);\n        });\n        return new MediaQueryDisjunction(conjunctions).optimize();\n    }\n    /** Preprocess simple query term by applying replacers and shortcuts rules */\n    static preprocess(term) {\n        if (!this.SHORTCUT_PATTERN.test(term))\n            return term;\n        const shortcut = term.trim().substring(1).toLowerCase();\n        for (const replacer of this._preprocessors) {\n            const result = replacer.process(shortcut);\n            if (typeof result === 'string')\n                return result;\n            if (typeof result === 'boolean')\n                return result ? 'all' : 'not all';\n        }\n        return term;\n    }\n    /** Creates simple {@link ESLMediaQuery} condition */\n    static parseSimpleQuery(term) {\n        const query = term.replace(/^\\s*not\\s+/, '');\n        const queryInverted = query !== term;\n        const processedQuery = ESLMediaQuery_1.preprocess(query);\n        const sanitizedQuery = processedQuery.replace(/^\\s*not\\s+/, '');\n        const resultInverted = processedQuery !== sanitizedQuery;\n        const invert = queryInverted !== resultInverted;\n        if (ALL.eq(sanitizedQuery))\n            return invert ? NOT_ALL : ALL;\n        if (NOT_ALL.eq(sanitizedQuery))\n            return invert ? ALL : NOT_ALL;\n        return new MediaQueryCondition(sanitizedQuery, invert);\n    }\n};\n/** Always true condition */\nESLMediaQuery.ALL = ALL;\n/** Always false condition */\nESLMediaQuery.NOT_ALL = NOT_ALL;\nESLMediaQuery.SHORTCUT_PATTERN = /@([a-z0-9.+-]+)/i;\nESLMediaQuery._preprocessors = [];\n__decorate([\n    memoize()\n], ESLMediaQuery, \"for\", null);\nESLMediaQuery = ESLMediaQuery_1 = __decorate([\n    ExportNs('MediaQuery')\n], ESLMediaQuery);\nexport { ESLMediaQuery };\n// Register otb preprocessors\nESLMediaQuery.use(ESLScreenDPR);\nESLMediaQuery.use(ESLScreenBreakpoints);\nESLMediaQuery.use(ESLEnvShortcuts);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ESLMediaRuleList_1;\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { Observable } from '../../esl-utils/abstract/observable';\nimport { evaluate } from '../../esl-utils/misc/format';\nimport { isPrimitive } from '../../esl-utils/misc/object';\nimport { ESLMediaRule } from './esl-media-rule';\n/**\n * ESLMediaRuleList - {@link ESLMediaRule} observable collection\n * @author Yuliya Adamskaya\n *\n * Represents observable object that wraps environment to value mapping\n */\nlet ESLMediaRuleList = ESLMediaRuleList_1 = class ESLMediaRuleList extends Observable {\n    constructor(rules) {\n        super();\n        this._rules = rules;\n        this._default = rules.filter((rule) => rule.default)[0];\n        this._onMatchChanged = this._onMatchChanged.bind(this);\n    }\n    static parse(query, parser = ESLMediaRuleList_1.STRING_PARSER) {\n        const rules = [];\n        query.split('|').forEach((part) => {\n            const lex = part.trim();\n            const rule = ESLMediaRule.parse(lex, parser);\n            if (!rule)\n                return;\n            rule.default ? rules.unshift(rule) : rules.push(rule);\n        });\n        return new ESLMediaRuleList_1(rules);\n    }\n    /**\n     * Creates `ESLMediaRuleList` from two strings with a value  and conditions tuple\n     *\n     * @param values - values tuple string (uses '|' as separator)\n     * @param mask - media conditions tuple string (uses '|' as separator)\n     *\n     * @example\n     * ```ts\n     * ESLMediaRuleList.fromTuple('1|2|3|4|5', '@XS|@SM|@MD|@LG|@XL')\n     * ```\n     */\n    static parseTuple(values, mask) {\n        const valueList = values.split('|');\n        const conditions = mask.split('|');\n        if (valueList.length !== conditions.length)\n            throw new Error('Value doesn\\'t correspond to mask');\n        const rules = conditions.map((query, i) => new ESLMediaRule(valueList[i], query));\n        return new ESLMediaRuleList_1(rules);\n    }\n    /** Subscribes to the instance active rule change */\n    addListener(listener) {\n        super.addListener(listener);\n        if (this._listeners.size > 1)\n            return;\n        this._rules.forEach((rule) => rule.addListener(this._onMatchChanged));\n    }\n    /** Unsubscribes from the instance active rule change */\n    removeListener(listener) {\n        super.removeListener(listener);\n        if (this._listeners.size)\n            return;\n        this._rules.forEach((rule) => rule.removeListener(this._onMatchChanged));\n    }\n    /** List of inner {@link ESLMediaRule}s */\n    get rules() {\n        return this._rules;\n    }\n    /** Cached active {@link ESLMediaRule} */\n    get active() {\n        if (!this._active || !this._listeners.size) {\n            this._active = this.activeRule;\n        }\n        return this._active;\n    }\n    /** Returns last active rule in the list */\n    get activeRule() {\n        const satisfiedRules = this.rules.filter((rule) => rule.matches);\n        return satisfiedRules.length > 0 ? satisfiedRules[satisfiedRules.length - 1] : ESLMediaRule.empty();\n    }\n    /** Active rule payload value */\n    get activeValue() {\n        const value = this.active.payload;\n        if (isPrimitive(value) || !this.default || isPrimitive(this.default.payload))\n            return value;\n        return Object.assign({}, this.default.payload || {}, value);\n    }\n    /** {@link ESLMediaRule} that is used as a default rule */\n    get default() {\n        return this._default;\n    }\n    /** Handle inner rules state change */\n    _onMatchChanged() {\n        const rule = this.activeRule;\n        if (this._active === rule)\n            return;\n        this.fire(this._active = rule, this);\n    }\n};\n/**\n * String value parser (used as a default)\n * @returns value string as it is\n */\nESLMediaRuleList.STRING_PARSER = (val) => val;\n/**\n * Object value parser. Uses {@link evaluate} to parse value\n * @returns value - parsed JS Object\n */\nESLMediaRuleList.OBJECT_PARSER = (val) => evaluate(val);\nESLMediaRuleList = ESLMediaRuleList_1 = __decorate([\n    ExportNs('MediaRuleList')\n], ESLMediaRuleList);\nexport { ESLMediaRuleList };\n","import { ESLMediaQuery } from './esl-media-query';\n/**\n * ESL Media Rule\n * @author Yuliya Adamskaya\n *\n * Helper class to wrap {@link ESLMediaQuery} with the payload value\n * @see ESLMediaQuery\n * @see ESLMediaRuleList\n */\nexport class ESLMediaRule {\n    constructor(payload, query = '') {\n        this._query = ESLMediaQuery.for(query);\n        this._default = !query;\n        this._payload = payload;\n    }\n    toString() {\n        return `${this._query} => ${this._payload}`;\n    }\n    /** Subscribes on inner {@link ESLMediaQuery} changes */\n    addListener(listener) {\n        this._query.addListener(listener);\n    }\n    /** Unsubscribes from inner {@link ESLMediaQuery} changes */\n    removeListener(listener) {\n        this._query.removeListener(listener);\n    }\n    /** Check if the inner {@link ESLMediaQuery} is matching current device configuration */\n    get matches() {\n        return this._query.matches;\n    }\n    /** @returns wrapped payload value */\n    get payload() {\n        return this._payload;\n    }\n    /**\n     * Check if the rule was created with an empty query\n     * @see ESLMediaRuleList\n     */\n    get default() {\n        return this._default;\n    }\n    /** Parse the rule string to the {@link ESLMediaRule} instance */\n    static parse(lex, parser) {\n        const parts = lex.split('=>');\n        const query = parts.length === 2 ? parts[0] : '';\n        const payload = parts.length === 2 ? parts[1] : parts[0];\n        const payloadValue = parser(payload.trim());\n        if (typeof payloadValue === 'undefined')\n            return undefined;\n        return new ESLMediaRule(payloadValue, query.trim());\n    }\n    /** Shortcut to create always active {@link ESLMediaRule} with passed value */\n    static all(payload) {\n        return new ESLMediaRule(payload, 'all');\n    }\n    /** Shortcut to create condition-less {@link ESLMediaRule} */\n    static default(payload) {\n        return new ESLMediaRule(payload);\n    }\n    /** Shortcut to create always inactive {@link ESLMediaRule} */\n    static empty() {\n        return new ESLMediaRule(undefined, 'all');\n    }\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ESLPanelGroup_1;\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { attr, jsonAttr, ESLBaseElement } from '../../esl-base-element/core';\nimport { afterNextRender } from '../../esl-utils/async/raf';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { format } from '../../esl-utils/misc/format';\nimport { memoize } from '../../esl-utils/decorators/memoize';\nimport { CSSClassUtils } from '../../esl-utils/dom/class';\nimport { ESLMediaRuleList } from '../../esl-media-query/core';\nimport { TraversingQuery } from '../../esl-traversing-query/core';\nimport { ESLPanel } from '../../esl-panel/core';\n/**\n * ESLPanelGroup component\n * @author Julia Murashko\n *\n * ESLPanelGroup is a custom element that is used as a container for a group of {@link ESLPanel}s\n */\nlet ESLPanelGroup = ESLPanelGroup_1 = class ESLPanelGroup extends ESLBaseElement {\n    constructor() {\n        super(...arguments);\n        /** Height of previous active panel */\n        this._previousHeight = 0;\n        /** Fallback setTimeout timer */\n        this._fallbackTimer = 0;\n    }\n    static get observedAttributes() {\n        return ['mode', 'accordion-group'];\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.bindEvents();\n        this.modeRules.addListener(this._onModeChange);\n        this.updateMode();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.modeRules.removeListener(this._onModeChange);\n        this.unbindEvents();\n    }\n    attributeChangedCallback(attrName, oldVal, newVal) {\n        if (!this.connected || oldVal === newVal)\n            return;\n        if (attrName === 'mode') {\n            this.modeRules.removeListener(this._onModeChange);\n            memoize.clear(this, 'modeRules');\n            this.modeRules.addListener(this._onModeChange);\n            this.updateMode();\n        }\n        if (attrName === 'accordion-group') {\n            if (newVal !== 'single' && newVal !== 'multiple') {\n                this.accordionGroup = oldVal;\n                return;\n            }\n            this.reset();\n        }\n    }\n    bindEvents() {\n        this.addEventListener('esl:before:show', this._onBeforeShow);\n        this.addEventListener('esl:show', this._onShow);\n        this.addEventListener('esl:before:hide', this._onBeforeHide);\n        this.addEventListener('transitionend', this._onTransitionEnd);\n    }\n    unbindEvents() {\n        this.removeEventListener('esl:before:show', this._onBeforeShow);\n        this.removeEventListener('esl:show', this._onShow);\n        this.removeEventListener('esl:before:hide', this._onBeforeHide);\n        this.removeEventListener('transitionend', this._onTransitionEnd);\n    }\n    /** Updates element state according to current mode */\n    updateMode() {\n        const prevMode = this.getAttribute('current-mode');\n        const currentMode = this.currentMode;\n        this.setAttribute('current-mode', currentMode);\n        // TODO: @deprecated will be removed with the 4th esl version\n        this.setAttribute('view', currentMode);\n        this.updateModeCls();\n        this.reset();\n        if (prevMode !== currentMode) {\n            this.$$fire('change:mode', { detail: { prevMode, currentMode } });\n        }\n    }\n    /** Updates mode class marker */\n    updateModeCls() {\n        const { modeCls, currentMode } = this;\n        if (!modeCls)\n            return;\n        const $target = TraversingQuery.first(this.modeClsTarget, this);\n        if (!$target)\n            return;\n        ESLPanelGroup_1.supportedModes.forEach((mode) => {\n            const className = format(modeCls, { mode });\n            $target.classList.toggle(className, currentMode === mode);\n        });\n    }\n    /** @returns ESLMediaRuleList instance of the mode mapping */\n    get modeRules() {\n        return ESLMediaRuleList.parse(this.mode);\n    }\n    /** @returns current mode */\n    get currentMode() {\n        return this.modeRules.activeValue || '';\n    }\n    /** @returns panels that are processed by the current panel group */\n    get $panels() {\n        const els = Array.from(this.querySelectorAll(ESLPanel.is));\n        return els.filter((el) => this.includesPanel(el));\n    }\n    /** @returns panels that are active */\n    get $activePanels() {\n        return this.$panels.filter((el) => el.open);\n    }\n    /** @returns whether the collapse/expand animation should be handheld by the group */\n    get shouldCollapse() {\n        const noCollapseModes = this.noCollapse.split(',').map((mode) => mode.trim());\n        return !noCollapseModes.includes('all') && !noCollapseModes.includes(this.currentMode);\n    }\n    /** @returns action params config that's used (inherited) by controlled {@link ESLPanel}s */\n    get panelConfig() {\n        return {\n            noCollapse: !this.shouldCollapse || (this.currentMode === 'tabs')\n        };\n    }\n    /** @returns merged panel action params for show/hide requests from the group */\n    mergeActionParams(...params) {\n        return Object.assign({ initiator: 'group', activator: this }, ...params);\n    }\n    /** Condition-guard to check if the passed target is a Panel that should be controlled by the Group */\n    includesPanel(target) {\n        if (!(target instanceof ESLPanel))\n            return false;\n        return target.$group === this;\n    }\n    /** Shows all panels besides excluded ones */\n    showAll(excluded = [], params = {}) {\n        this.$panels.forEach((el) => !excluded.includes(el) && el.show(this.mergeActionParams(params)));\n    }\n    /** Hides all active panels besides excluded ones */\n    hideAll(excluded = [], params = {}) {\n        this.$activePanels.forEach((el) => !excluded.includes(el) && el.hide(this.mergeActionParams(params)));\n    }\n    /** Toggles all panels by predicate */\n    toggleAllBy(shouldOpen, params = {}) {\n        this.$panels.forEach((panel) => panel.toggle(shouldOpen(panel), this.mergeActionParams(params)));\n    }\n    /** Resets to default state applicable to the current mode */\n    reset() {\n        ESLPanel.registered.then(() => {\n            if (this.currentMode === 'open')\n                this.toggleAllBy(() => true, this.transformParams);\n            if (this.currentMode === 'tabs' || (this.currentMode === 'accordion' && this.accordionGroup === 'single')) {\n                const $activePanel = this.$panels.find((panel) => panel.initiallyOpened);\n                this.toggleAllBy((panel) => panel === $activePanel, this.transformParams);\n            }\n            if (this.currentMode === 'accordion' && this.accordionGroup === 'multiple') {\n                this.toggleAllBy((panel) => panel.initiallyOpened, this.transformParams);\n            }\n        });\n    }\n    /** Animates the height of the component */\n    onAnimate(from, to) {\n        const hasCurrent = this.style.height && this.style.height !== 'auto';\n        if (hasCurrent) {\n            this.style.height = `${to}px`;\n            this.fallbackAnimate();\n        }\n        else {\n            // set initial height\n            this.style.height = `${from}px`;\n            // make sure that browser apply initial height to animate\n            afterNextRender(() => {\n                this.style.height = `${to}px`;\n                this.fallbackAnimate();\n            });\n        }\n    }\n    /** Pre-processing animation action */\n    beforeAnimate() {\n        CSSClassUtils.add(this, this.animationClass);\n    }\n    /** Post-processing animation action */\n    afterAnimate() {\n        this.style.removeProperty('height');\n        CSSClassUtils.remove(this, this.animationClass);\n    }\n    /** Inits a fallback timer to call post-animate action */\n    fallbackAnimate() {\n        const time = +this.fallbackDuration;\n        if (isNaN(time) || time < 0)\n            return;\n        if (this._fallbackTimer)\n            clearTimeout(this._fallbackTimer);\n        this._fallbackTimer = window.setTimeout(() => this.afterAnimate(), time);\n    }\n    /** Process {@link ESLPanel} pre-show event */\n    _onBeforeShow(e) {\n        const panel = e.target;\n        if (!this.includesPanel(panel))\n            return;\n        if (this.currentMode === 'accordion' && this.accordionGroup === 'multiple')\n            return;\n        this.hideAll([panel]);\n    }\n    /** Process {@link ESLPanel} show event */\n    _onShow(e) {\n        const panel = e.target;\n        if (!this.includesPanel(panel))\n            return;\n        if (this.currentMode !== 'tabs')\n            return;\n        this.beforeAnimate();\n        if (this.shouldCollapse) {\n            this.onAnimate(this._previousHeight, panel.initialHeight);\n        }\n        else {\n            afterNextRender(() => this.afterAnimate());\n        }\n    }\n    /** Process {@link ESLPanel} pre-hide event */\n    _onBeforeHide(e) {\n        // TODO: refactor\n        if (this.currentMode === 'open') {\n            e.preventDefault();\n            return;\n        }\n        const panel = e.target;\n        if (!this.includesPanel(panel))\n            return;\n        this._previousHeight = this.offsetHeight;\n    }\n    /** Catches CSS transition end event to start post-animate processing */\n    _onTransitionEnd(e) {\n        if (!e || e.propertyName === 'height') {\n            this.afterAnimate();\n        }\n    }\n    /** Handles mode change */\n    _onModeChange() {\n        this.updateMode();\n    }\n};\nESLPanelGroup.is = 'esl-panel-group';\n/** List of supported modes */\nESLPanelGroup.supportedModes = ['tabs', 'accordion', 'open'];\n__decorate([\n    attr({ defaultValue: 'accordion' })\n], ESLPanelGroup.prototype, \"mode\", void 0);\n__decorate([\n    attr({ defaultValue: 'esl-{mode}-view' })\n], ESLPanelGroup.prototype, \"modeCls\", void 0);\n__decorate([\n    attr({ defaultValue: '' })\n], ESLPanelGroup.prototype, \"modeClsTarget\", void 0);\n__decorate([\n    attr({ defaultValue: 'animate' })\n], ESLPanelGroup.prototype, \"animationClass\", void 0);\n__decorate([\n    attr({ defaultValue: 'auto' })\n], ESLPanelGroup.prototype, \"fallbackDuration\", void 0);\n__decorate([\n    attr()\n], ESLPanelGroup.prototype, \"noCollapse\", void 0);\n__decorate([\n    attr({ defaultValue: 'single' })\n], ESLPanelGroup.prototype, \"accordionGroup\", void 0);\n__decorate([\n    jsonAttr({ defaultValue: { noCollapse: true } })\n], ESLPanelGroup.prototype, \"transformParams\", void 0);\n__decorate([\n    memoize()\n], ESLPanelGroup.prototype, \"modeRules\", null);\n__decorate([\n    bind\n], ESLPanelGroup.prototype, \"_onBeforeShow\", null);\n__decorate([\n    bind\n], ESLPanelGroup.prototype, \"_onShow\", null);\n__decorate([\n    bind\n], ESLPanelGroup.prototype, \"_onBeforeHide\", null);\n__decorate([\n    bind\n], ESLPanelGroup.prototype, \"_onTransitionEnd\", null);\n__decorate([\n    bind\n], ESLPanelGroup.prototype, \"_onModeChange\", null);\nESLPanelGroup = ESLPanelGroup_1 = __decorate([\n    ExportNs('PanelGroup')\n], ESLPanelGroup);\nexport { ESLPanelGroup };\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { CSSClassUtils } from '../../esl-utils/dom/class';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { afterNextRender } from '../../esl-utils/async/raf';\nimport { attr, boolAttr, jsonAttr } from '../../esl-base-element/core';\nimport { ESLToggleable } from '../../esl-toggleable/core';\nimport { ESLPanelGroup } from '../../esl-panel-group/core';\n/**\n * ESLPanel component\n * @author Julia Murashko\n *\n * ESLPanel is a custom element that is used as a wrapper for content that can be shown or hidden.\n * Can use collapsing/expanding animation (smooth height change).\n * Can be used in conjunction with {@link ESLPanelGroup} to control a group of ESLPopups\n */\nlet ESLPanel = class ESLPanel extends ESLToggleable {\n    constructor() {\n        super(...arguments);\n        /** Inner height state that updates after show/hide actions but before show/hide events triggered */\n        this._initialHeight = 0;\n        /** Inner timer to cleanup animation styles */\n        this._fallbackTimer = 0;\n    }\n    /** @returns Previous active panel height at the start of the animation */\n    get initialHeight() {\n        return this._initialHeight;\n    }\n    /** @returns Closest panel group or null if not presented */\n    get $group() {\n        if (this.groupName === 'none' || this.groupName)\n            return null;\n        return this.closest(ESLPanelGroup.is);\n    }\n    bindEvents() {\n        super.bindEvents();\n        this.addEventListener('transitionend', this._onTransitionEnd);\n    }\n    unbindEvents() {\n        super.unbindEvents();\n        this.removeEventListener('transitionend', this._onTransitionEnd);\n    }\n    /** Process show action */\n    onShow(params) {\n        this._initialHeight = this.scrollHeight;\n        super.onShow(params);\n        this.beforeAnimate();\n        if (params.noCollapse) {\n            afterNextRender(() => this.afterAnimate());\n        }\n        else {\n            this.onAnimate('show');\n        }\n    }\n    /** Process hide action */\n    onHide(params) {\n        this._initialHeight = this.scrollHeight;\n        super.onHide(params);\n        this.beforeAnimate();\n        if (params.noCollapse) {\n            afterNextRender(() => this.afterAnimate());\n        }\n        else {\n            this.onAnimate('hide');\n        }\n    }\n    /** Pre-processing animation action */\n    beforeAnimate() {\n        this.toggleAttribute('animating', true);\n        CSSClassUtils.add(this, this.animateClass);\n        this.postAnimateClass && afterNextRender(() => CSSClassUtils.add(this, this.postAnimateClass));\n    }\n    /** Process animation */\n    onAnimate(action) {\n        // set initial height\n        this.style.setProperty('max-height', `${action === 'hide' ? this._initialHeight : 0}px`);\n        // make sure that browser apply initial height for animation\n        afterNextRender(() => {\n            this.style.setProperty('max-height', `${action === 'hide' ? 0 : this._initialHeight}px`);\n            this.fallbackAnimate();\n        });\n    }\n    /** Post-processing animation action */\n    afterAnimate() {\n        this.clearAnimation();\n        this.$$fire(this.open ? 'after:show' : 'after:hide');\n    }\n    /** Clear animation properties */\n    clearAnimation() {\n        this.toggleAttribute('animating', false);\n        this.style.removeProperty('max-height');\n        CSSClassUtils.remove(this, this.animateClass);\n        CSSClassUtils.remove(this, this.postAnimateClass);\n    }\n    /** Init a fallback timer to call post-animate action */\n    fallbackAnimate() {\n        const time = +this.fallbackDuration;\n        if (isNaN(time) || time < 0)\n            return;\n        if (this._fallbackTimer)\n            clearTimeout(this._fallbackTimer);\n        this._fallbackTimer = window.setTimeout(() => this.afterAnimate(), time);\n    }\n    /** Catching CSS transition end event to start post-animate processing */\n    _onTransitionEnd(e) {\n        if (!e || e.propertyName === 'max-height') {\n            this.afterAnimate();\n        }\n    }\n    /** Merge params that are used by panel group for actions */\n    mergeDefaultParams(params) {\n        var _a;\n        const stackConfig = ((_a = this.$group) === null || _a === void 0 ? void 0 : _a.panelConfig) || {};\n        return Object.assign({}, stackConfig, this.defaultParams, params || {});\n    }\n};\nESLPanel.is = 'esl-panel';\n__decorate([\n    attr({ defaultValue: 'open' })\n], ESLPanel.prototype, \"activeClass\", void 0);\n__decorate([\n    attr({ defaultValue: 'animate' })\n], ESLPanel.prototype, \"animateClass\", void 0);\n__decorate([\n    attr({ defaultValue: 'post-animate' })\n], ESLPanel.prototype, \"postAnimateClass\", void 0);\n__decorate([\n    attr({ defaultValue: '1000' })\n], ESLPanel.prototype, \"fallbackDuration\", void 0);\n__decorate([\n    jsonAttr({ defaultValue: { force: true, initiator: 'init' } })\n], ESLPanel.prototype, \"initialParams\", void 0);\n__decorate([\n    boolAttr({ readonly: true })\n], ESLPanel.prototype, \"animating\", void 0);\n__decorate([\n    bind\n], ESLPanel.prototype, \"_onTransitionEnd\", null);\nESLPanel = __decorate([\n    ExportNs('Panel')\n], ESLPanel);\nexport { ESLPanel };\n","import { Rect } from '../../esl-utils/dom/rect';\n/**\n * Checks that the position along the horizontal axis\n * @param position - name of position\n */\nexport function isMajorAxisHorizontal(position) {\n    return ['left', 'right'].includes(position);\n}\n/**\n * Calculates the position of the popup on the minor axis\n * @param cfg - popup position config\n * @param centerPosition - position of the center of the trigger on the minor axis\n * @param dimensionName - the name of dimension (height or width)\n */\nfunction calcPopupPositionByMinorAxis(cfg, centerPosition, dimensionName) {\n    return centerPosition - cfg.arrow[dimensionName] / 2 - cfg.marginArrow - calcUsableSizeForArrow(cfg, dimensionName) * cfg.offsetArrowRatio;\n}\n/**\n * TODO: optimize switch\n * Calculate Rect for given popup position config.\n * @param cfg - popup position config\n * */\nfunction calcPopupBasicRect(cfg) {\n    let x = calcPopupPositionByMinorAxis(cfg, cfg.inner.cx, 'width');\n    let y = cfg.inner.y - cfg.element.height;\n    switch (cfg.position) {\n        case 'left':\n            x = cfg.inner.x - cfg.element.width;\n            y = calcPopupPositionByMinorAxis(cfg, cfg.inner.cy, 'height');\n            break;\n        case 'right':\n            x = cfg.inner.right;\n            y = calcPopupPositionByMinorAxis(cfg, cfg.inner.cy, 'height');\n            break;\n        case 'bottom':\n            x = calcPopupPositionByMinorAxis(cfg, cfg.inner.cx, 'width');\n            y = cfg.inner.bottom;\n            break;\n    }\n    return new Rect(x, y, cfg.element.width, cfg.element.height);\n}\n/**\n * Get opposite position.\n * @param position - name of position\n * */\nfunction getOppositePosition(position) {\n    return ({\n        top: 'bottom',\n        left: 'right',\n        right: 'left',\n        bottom: 'top'\n    }[position] || position);\n}\n/**\n * TODO: move the actionsToFit definition outside the function and optimize\n * Update popup and arrow positions to fit on major axis.\n * @param cfg - popup position config\n * @param rect - popup position rect\n * @param arrow - arrow position value\n * */\nfunction fitOnMajorAxis(cfg, rect, arrow) {\n    if (cfg.behavior !== 'fit' && cfg.behavior !== 'fit-on-major')\n        return cfg.position;\n    let isMirrored = false;\n    const actionsToFit = {\n        'bottom': () => {\n            if (cfg.intersectionRatio.bottom || cfg.outer.bottom < rect.bottom) {\n                rect.y = cfg.inner.top - cfg.element.height;\n                isMirrored = true;\n            }\n        },\n        'left': () => {\n            if (cfg.intersectionRatio.left || rect.x < cfg.outer.x) {\n                rect.x = cfg.inner.right;\n                isMirrored = true;\n            }\n        },\n        'right': () => {\n            if (cfg.intersectionRatio.right || cfg.outer.right < rect.right) {\n                rect.x = cfg.inner.x - cfg.element.width;\n                isMirrored = true;\n            }\n        },\n        'top': () => {\n            if (cfg.intersectionRatio.top || rect.y < cfg.outer.y) {\n                rect.y = cfg.inner.bottom;\n                isMirrored = true;\n            }\n        }\n    };\n    actionsToFit[cfg.position]();\n    return isMirrored ? getOppositePosition(cfg.position) : cfg.position;\n}\n/**\n * TODO: rethink fitOnMinorAxisHorizontal and fitOnMinorAxisVertical to simplify code\n * Update popup and arrow positions to fit on minor horizontal axis.\n * @param cfg - popup position config\n * @param rect - popup position rect\n * @param arrow - arrow position value\n * */\nfunction fitOnMinorAxisHorizontal(cfg, rect, arrow) {\n    if (cfg.outer.width < cfg.element.width || // cancel fit mode if the popup width is greater than the outer limiter width\n        cfg.trigger.x < cfg.outer.x || // or the trigger is outside the outer limiting element\n        cfg.trigger.right > cfg.outer.right)\n        return;\n    let arrowAdjust = 0;\n    if (rect.x < cfg.outer.x) {\n        arrowAdjust = rect.x - cfg.outer.x;\n        rect.x = cfg.outer.x;\n    }\n    if (rect.right > cfg.outer.right) {\n        arrowAdjust = rect.right - cfg.outer.right;\n        rect.x -= arrowAdjust;\n    }\n    arrow.x += arrowAdjust;\n}\n/**\n * TODO: see Idea warning regarding duplication\n * Update popup and arrow positions to fit by minor vertical axis.\n * @param cfg - popup position config\n * @param rect - popup position rect\n * @param arrow - arrow position value\n * */\nfunction fitOnMinorAxisVertical(cfg, rect, arrow) {\n    if (cfg.outer.height < cfg.element.height || // cancel fit mode if the popup height is greater than the outer limiter height\n        cfg.trigger.y < cfg.outer.y || // or the trigger is outside the outer limiting element\n        cfg.trigger.bottom > cfg.outer.bottom)\n        return;\n    let arrowAdjust = 0;\n    if (rect.y < cfg.outer.y) {\n        arrowAdjust = rect.y - cfg.outer.y;\n        rect.y = cfg.outer.y;\n    }\n    if (rect.bottom > cfg.outer.bottom) {\n        arrowAdjust = rect.bottom - cfg.outer.bottom;\n        rect.y -= arrowAdjust;\n    }\n    arrow.y += arrowAdjust;\n}\n/**\n * Update popup and arrow positions to fit on minor axis.\n * @param cfg - popup position config\n * @param rect - popup position rect\n * @param arrow - arrow position value\n * */\nfunction fitOnMinorAxis(cfg, rect, arrow) {\n    if (cfg.behavior !== 'fit' && cfg.behavior !== 'fit-on-minor')\n        return;\n    if (isMajorAxisHorizontal(cfg.position)) {\n        fitOnMinorAxisVertical(cfg, rect, arrow);\n    }\n    else {\n        fitOnMinorAxisHorizontal(cfg, rect, arrow);\n    }\n}\n/**\n * Calculate the usable size available for the arrow\n * @param cfg - popup position config\n * @param dimensionName - the name of dimension (height or width)\n */\nfunction calcUsableSizeForArrow(cfg, dimensionName) {\n    return cfg.element[dimensionName] - cfg.arrow[dimensionName] - 2 * cfg.marginArrow;\n}\n/**\n * Calculates the position of the arrow on the minor axis\n * @param cfg - popup position config\n * @param dimensionName - the name of dimension (height or width)\n */\nfunction calcArrowPosition(cfg, dimensionName) {\n    return cfg.marginArrow + calcUsableSizeForArrow(cfg, dimensionName) * cfg.offsetArrowRatio;\n}\n/**\n * Calculate popup and arrow popup positions.\n * @param cfg - popup position config\n * */\nexport function calcPopupPosition(cfg) {\n    const popup = calcPopupBasicRect(cfg);\n    const arrow = {\n        x: calcArrowPosition(cfg, 'width'),\n        y: calcArrowPosition(cfg, 'height'),\n        position: cfg.position\n    };\n    const placedAt = fitOnMajorAxis(cfg, popup, arrow);\n    fitOnMinorAxis(cfg, popup, arrow);\n    return {\n        popup,\n        placedAt,\n        arrow\n    };\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { range } from '../../esl-utils/misc/array';\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { attr, boolAttr, jsonAttr } from '../../esl-base-element/core';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { memoize } from '../../esl-utils/decorators/memoize';\nimport { ready } from '../../esl-utils/decorators/ready';\nimport { prop } from '../../esl-utils/decorators/prop';\nimport { afterNextRender, rafDecorator } from '../../esl-utils/async/raf';\nimport { ESLToggleable } from '../../esl-toggleable/core';\nimport { Rect } from '../../esl-utils/dom/rect';\nimport { RTLUtils } from '../../esl-utils/dom/rtl';\nimport { getListScrollParents } from '../../esl-utils/dom/scroll';\nimport { getWindowRect } from '../../esl-utils/dom/window';\nimport { parseNumber } from '../../esl-utils/misc/format';\nimport { calcPopupPosition, isMajorAxisHorizontal } from './esl-popup-position';\nconst INTERSECTION_LIMIT_FOR_ADJACENT_AXIS = 0.7;\nconst DEFAULT_OFFSET_ARROW = 50;\nconst scrollOptions = { passive: true };\nconst parsePercent = (value, nanValue = 0) => {\n    const rawValue = parseNumber(value, nanValue);\n    return Math.max(0, Math.min(rawValue !== undefined ? rawValue : nanValue, 100));\n};\nlet ESLPopup = class ESLPopup extends ESLToggleable {\n    constructor() {\n        super(...arguments);\n        this._deferredUpdatePosition = rafDecorator(() => this._updatePosition());\n        this._intersectionRatio = {};\n        this.closeOnEsc = true;\n        this.closeOnOutsideAction = true;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.$arrow = this.querySelector('span.esl-popup-arrow');\n    }\n    /** Checks that the position along the horizontal axis */\n    get _isMajorAxisHorizontal() {\n        return isMajorAxisHorizontal(this.position);\n    }\n    /** Checks that the position along the vertical axis */\n    get _isMajorAxisVertical() {\n        return !isMajorAxisHorizontal(this.position);\n    }\n    /** Get offsets arrow ratio */\n    get _offsetArrowRatio() {\n        const ratio = parsePercent(this.offsetArrow, DEFAULT_OFFSET_ARROW) / 100;\n        return RTLUtils.isRtl(this) ? 1 - ratio : ratio;\n    }\n    /**\n     * Actions to execute on show popup.\n     * Inner state and 'open' attribute are not affected and updated before `onShow` execution.\n     * Adds CSS classes, update a11y and fire esl:refresh event by default.\n     */\n    onShow(params) {\n        super.onShow(params);\n        if (params.position) {\n            this.position = params.position;\n        }\n        if (params.behavior) {\n            this.behavior = params.behavior;\n        }\n        if (params.disableActivatorObservation) {\n            this.disableActivatorObservation = params.disableActivatorObservation;\n        }\n        if (params.marginArrow) {\n            this.marginArrow = params.marginArrow;\n        }\n        if (params.offsetArrow) {\n            this.offsetArrow = params.offsetArrow;\n        }\n        this._offsetTrigger = params.offsetTrigger || 0;\n        this._offsetWindow = params.offsetWindow || 0;\n        this.style.visibility = 'hidden'; // eliminates the blinking of the popup at the previous position\n        afterNextRender(() => this.afterOnShow()); // running as a separate task solves the problem with incorrect positioning on the first showing\n    }\n    /**\n     * Actions to execute on hide popup.\n     * Inner state and 'open' attribute are not affected and updated before `onShow` execution.\n     * Removes CSS classes and updates a11y by default.\n     */\n    onHide(params) {\n        this.beforeOnHide();\n        super.onHide(params);\n        this._stopUpdateLoop();\n        this.activator && this._removeActivatorObserver(this.activator);\n        // clear all memoize data\n        memoize.clear(this, '_isMajorAxisHorizontal');\n        memoize.clear(this, '_isMajorAxisVertical');\n        memoize.clear(this, '_offsetArrowRatio');\n    }\n    /**\n     * Actions to execute after showing of popup.\n     */\n    afterOnShow() {\n        this._updatePosition();\n        this.style.visibility = 'visible';\n        this.activator && this._addActivatorObserver(this.activator);\n        this._startUpdateLoop();\n    }\n    /**\n     * Actions to execute before hiding of popup.\n     */\n    beforeOnHide() { }\n    /**\n     * Checks activator intersection for adjacent axis.\n     * Hides the popup if the intersection ratio exceeds the limit.\n     */\n    _checkIntersectionForAdjacentAxis(isAdjacentAxis, intersectionRatio) {\n        if (isAdjacentAxis && intersectionRatio < INTERSECTION_LIMIT_FOR_ADJACENT_AXIS) {\n            this.hide();\n        }\n    }\n    /** Actions to execute on activator intersection event. */\n    onActivatorIntersection(entries, observer) {\n        const entry = entries[0];\n        this._intersectionRatio = {};\n        if (!entry.isIntersecting) {\n            this.hide();\n            return;\n        }\n        if (entry.intersectionRect.y !== entry.boundingClientRect.y) {\n            this._intersectionRatio.top = entry.intersectionRect.height / entry.boundingClientRect.height;\n            this._checkIntersectionForAdjacentAxis(this._isMajorAxisHorizontal, this._intersectionRatio.top);\n        }\n        if (entry.intersectionRect.bottom !== entry.boundingClientRect.bottom) {\n            this._intersectionRatio.bottom = entry.intersectionRect.height / entry.boundingClientRect.height;\n            this._checkIntersectionForAdjacentAxis(this._isMajorAxisHorizontal, this._intersectionRatio.bottom);\n        }\n        if (entry.intersectionRect.x !== entry.boundingClientRect.x) {\n            this._intersectionRatio.left = entry.intersectionRect.width / entry.boundingClientRect.width;\n            this._checkIntersectionForAdjacentAxis(this._isMajorAxisVertical, this._intersectionRatio.left);\n        }\n        if (entry.intersectionRect.right !== entry.boundingClientRect.right) {\n            this._intersectionRatio.right = entry.intersectionRect.width / entry.boundingClientRect.width;\n            this._checkIntersectionForAdjacentAxis(this._isMajorAxisVertical, this._intersectionRatio.right);\n        }\n    }\n    /** Actions to execute on activator scroll event. */\n    onActivatorScroll(e) {\n        if (this._updateLoopID)\n            return;\n        this._updatePosition();\n    }\n    /** Creates listeners and observers to observe activator after showing popup */\n    _addActivatorObserver(target) {\n        const scrollParents = getListScrollParents(target);\n        this._activatorObserver = {\n            unsubscribers: scrollParents.map(($root) => {\n                $root.addEventListener('scroll', this.onActivatorScroll, scrollOptions);\n                return () => {\n                    $root && $root.removeEventListener('scroll', this.onActivatorScroll, scrollOptions);\n                };\n            })\n        };\n        if (!this.disableActivatorObservation) {\n            const options = {\n                rootMargin: '0px',\n                threshold: range(9, (x) => x / 8)\n            };\n            const observer = new IntersectionObserver(this.onActivatorIntersection, options);\n            observer.observe(target);\n            this._activatorObserver.observer = observer;\n        }\n        window.addEventListener('resize', this._deferredUpdatePosition);\n        window.addEventListener('scroll', this.onActivatorScroll, scrollOptions);\n        document.body.addEventListener('transitionstart', this._startUpdateLoop);\n    }\n    /** Removes activator listeners and observers after hiding popup */\n    _removeActivatorObserver(target) {\n        var _a, _b;\n        window.removeEventListener('resize', this._deferredUpdatePosition);\n        window.removeEventListener('scroll', this.onActivatorScroll, scrollOptions);\n        (_a = this._activatorObserver.observer) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this._activatorObserver.observer = undefined;\n        (_b = this._activatorObserver.unsubscribers) === null || _b === void 0 ? void 0 : _b.forEach((cb) => cb());\n        this._activatorObserver.unsubscribers = [];\n        document.body.removeEventListener('transitionstart', this._startUpdateLoop);\n    }\n    /**\n     * Starts loop for update position of popup.\n     * The loop ends when the position and size of the activator have not changed\n     * for the last 2 frames of the animation.\n     */\n    _startUpdateLoop() {\n        if (this._updateLoopID)\n            return;\n        let same = 0;\n        let lastRect = new Rect();\n        const updateLoop = () => {\n            if (!this.activator) {\n                this._stopUpdateLoop();\n                return;\n            }\n            const newRect = Rect.from(this.activator.getBoundingClientRect());\n            if (!Rect.isEqual(lastRect, newRect)) {\n                same = 0;\n                lastRect = newRect;\n            }\n            if (same++ > 2) {\n                this._stopUpdateLoop();\n                return;\n            }\n            this._updatePosition();\n            this._updateLoopID = requestAnimationFrame(updateLoop);\n        };\n        this._updateLoopID = requestAnimationFrame(updateLoop);\n    }\n    /**\n     * Stops loop for update position of popup.\n     * Also cancels the animation frame request.\n     */\n    _stopUpdateLoop() {\n        if (!this._updateLoopID)\n            return;\n        cancelAnimationFrame(this._updateLoopID);\n        this._updateLoopID = 0;\n    }\n    /** Updates position of popup and its arrow */\n    _updatePosition() {\n        if (!this.activator)\n            return;\n        const triggerRect = this.activator.getBoundingClientRect();\n        const popupRect = this.getBoundingClientRect();\n        const arrowRect = this.$arrow ? this.$arrow.getBoundingClientRect() : new Rect();\n        const trigger = new Rect(triggerRect.left, triggerRect.top + window.pageYOffset, triggerRect.width, triggerRect.height);\n        const innerMargin = this._offsetTrigger + arrowRect.width / 2;\n        const config = {\n            position: this.position,\n            behavior: this.behavior,\n            marginArrow: +this.marginArrow,\n            offsetArrowRatio: this._offsetArrowRatio,\n            intersectionRatio: this._intersectionRatio,\n            arrow: arrowRect,\n            element: popupRect,\n            trigger,\n            inner: Rect.from(trigger).grow(innerMargin),\n            outer: getWindowRect().shrink(this._offsetWindow)\n        };\n        const { placedAt, popup, arrow } = calcPopupPosition(config);\n        this.setAttribute('placed-at', placedAt);\n        // set popup position\n        this.style.left = `${popup.x}px`;\n        this.style.top = `${popup.y}px`;\n        // set arrow position\n        if (this.$arrow) {\n            this.$arrow.style.left = this._isMajorAxisVertical ? `${arrow.x}px` : '';\n            this.$arrow.style.top = this._isMajorAxisHorizontal ? `${arrow.y}px` : '';\n        }\n    }\n};\nESLPopup.is = 'esl-popup';\n__decorate([\n    attr({ defaultValue: 'top' })\n], ESLPopup.prototype, \"position\", void 0);\n__decorate([\n    attr({ defaultValue: 'fit' })\n], ESLPopup.prototype, \"behavior\", void 0);\n__decorate([\n    boolAttr()\n], ESLPopup.prototype, \"disableActivatorObservation\", void 0);\n__decorate([\n    attr({ defaultValue: '5' })\n], ESLPopup.prototype, \"marginArrow\", void 0);\n__decorate([\n    attr({ defaultValue: `${DEFAULT_OFFSET_ARROW}` })\n], ESLPopup.prototype, \"offsetArrow\", void 0);\n__decorate([\n    jsonAttr({ defaultValue: {\n            offsetTrigger: 3,\n            offsetWindow: 15\n        } })\n], ESLPopup.prototype, \"defaultParams\", void 0);\n__decorate([\n    prop()\n], ESLPopup.prototype, \"closeOnEsc\", void 0);\n__decorate([\n    prop()\n], ESLPopup.prototype, \"closeOnOutsideAction\", void 0);\n__decorate([\n    ready\n], ESLPopup.prototype, \"connectedCallback\", null);\n__decorate([\n    memoize()\n], ESLPopup.prototype, \"_isMajorAxisHorizontal\", null);\n__decorate([\n    memoize()\n], ESLPopup.prototype, \"_isMajorAxisVertical\", null);\n__decorate([\n    memoize()\n], ESLPopup.prototype, \"_offsetArrowRatio\", null);\n__decorate([\n    bind\n], ESLPopup.prototype, \"onActivatorIntersection\", null);\n__decorate([\n    bind\n], ESLPopup.prototype, \"onActivatorScroll\", null);\n__decorate([\n    bind\n], ESLPopup.prototype, \"_startUpdateLoop\", null);\n__decorate([\n    bind\n], ESLPopup.prototype, \"_stopUpdateLoop\", null);\nESLPopup = __decorate([\n    ExportNs('Popup')\n], ESLPopup);\nexport { ESLPopup };\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { ESLBaseElement, attr, boolAttr } from '../../esl-base-element/core';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { ready } from '../../esl-utils/decorators/ready';\nimport { rafDecorator } from '../../esl-utils/async/raf';\nimport { EventUtils } from '../../esl-utils/dom/events';\nimport { isRelativeNode } from '../../esl-utils/dom/traversing';\nimport { TraversingQuery } from '../../esl-traversing-query/core';\nimport { RTLUtils } from '../../esl-utils/dom/rtl';\n/**\n * ESLScrollbar is a reusable web component that replaces the browser's default scrollbar with\n * a custom scrollbar implementation.\n *\n * @author Yuliya Adamskaya\n */\nlet ESLScrollbar = class ESLScrollbar extends ESLBaseElement {\n    constructor() {\n        super(...arguments);\n        this._deferredDrag = rafDecorator((e) => this._onPointerDrag(e));\n        this._deferredRefresh = rafDecorator(() => this.refresh());\n        this._scrollTimer = 0;\n        this._resizeObserver = new ResizeObserver(this._deferredRefresh);\n        this._mutationObserver = new MutationObserver((rec) => this.updateContentObserve(rec));\n    }\n    static get observedAttributes() {\n        return ['target', 'horizontal'];\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.findTarget();\n        this.render();\n        this.bindEvents();\n    }\n    disconnectedCallback() {\n        this.unbindEvents();\n        this._scrollTimer && window.clearTimeout(this._scrollTimer);\n    }\n    attributeChangedCallback(attrName, oldVal, newVal) {\n        if (!this.connected && oldVal === newVal)\n            return;\n        if (attrName === 'target')\n            this.findTarget();\n        if (attrName === 'horizontal')\n            this.refresh();\n    }\n    findTarget() {\n        this.$target = this.target ?\n            TraversingQuery.first(this.target, this) :\n            null;\n    }\n    /** Target element to observe and scroll */\n    get $target() {\n        return this._$target || null;\n    }\n    set $target(content) {\n        this.unbindTargetEvents();\n        this._$target = content;\n        this.bindTargetEvents();\n        this._deferredRefresh();\n    }\n    render() {\n        this.innerHTML = '';\n        this.$scrollbarTrack = document.createElement('div');\n        this.$scrollbarTrack.className = this.trackClass;\n        this.$scrollbarThumb = document.createElement('div');\n        this.$scrollbarThumb.className = this.thumbClass;\n        this.$scrollbarTrack.appendChild(this.$scrollbarThumb);\n        this.appendChild(this.$scrollbarTrack);\n    }\n    bindEvents() {\n        window.MouseEvent && this.addEventListener('mousedown', this._onPointerDown);\n        window.TouchEvent && this.addEventListener('touchstart', this._onPointerDown);\n        window.addEventListener('esl:refresh', this._onRefresh);\n    }\n    bindTargetEvents() {\n        if (!this.$target)\n            return;\n        if (document.documentElement === this.$target) {\n            window.addEventListener('resize', this._onRefresh, { passive: true });\n            window.addEventListener('scroll', this._onRefresh, { passive: true });\n        }\n        else {\n            this._resizeObserver.observe(this.$target);\n            this._mutationObserver.observe(this.$target, { childList: true });\n            Array.from(this.$target.children).forEach((el) => this._resizeObserver.observe(el));\n            this.$target.addEventListener('scroll', this._onRefresh, { passive: true });\n        }\n    }\n    updateContentObserve(recs = []) {\n        if (!this.$target)\n            return;\n        const contentChanges = recs.filter((rec) => rec.type === 'childList');\n        contentChanges.forEach((rec) => {\n            Array.from(rec.addedNodes)\n                .filter((el) => el instanceof Element)\n                .forEach((el) => this._resizeObserver.observe(el));\n            Array.from(rec.removedNodes)\n                .filter((el) => el instanceof Element)\n                .forEach((el) => this._resizeObserver.unobserve(el));\n        });\n        if (contentChanges.length)\n            this._deferredRefresh();\n    }\n    unbindEvents() {\n        window.MouseEvent && this.removeEventListener('mousedown', this._onPointerDown);\n        window.TouchEvent && this.removeEventListener('touchstart', this._onPointerDown);\n        this.unbindTargetEvents();\n        window.removeEventListener('esl:refresh', this._onRefresh);\n    }\n    unbindTargetEvents() {\n        if (!this.$target)\n            return;\n        if (document.documentElement === this.$target) {\n            window.removeEventListener('resize', this._onRefresh);\n            window.removeEventListener('scroll', this._onRefresh);\n        }\n        else {\n            this._resizeObserver.disconnect();\n            this._mutationObserver.disconnect();\n            this.$target.removeEventListener('scroll', this._onRefresh);\n        }\n    }\n    /** @readonly Scrollable distance size value (px) */\n    get scrollableSize() {\n        if (!this.$target)\n            return 0;\n        return this.horizontal ?\n            this.$target.scrollWidth - this.$target.clientWidth :\n            this.$target.scrollHeight - this.$target.clientHeight;\n    }\n    /** @readonly Track size value (px) */\n    get trackOffset() {\n        return this.horizontal ? this.$scrollbarTrack.offsetWidth : this.$scrollbarTrack.offsetHeight;\n    }\n    /** @readonly Thumb size value (px) */\n    get thumbOffset() {\n        return this.horizontal ? this.$scrollbarThumb.offsetWidth : this.$scrollbarThumb.offsetHeight;\n    }\n    /** @readonly Relative thumb size value (between 0.0 and 1.0) */\n    get thumbSize() {\n        // behave as native scroll\n        if (!this.$target || !this.$target.scrollWidth || !this.$target.scrollHeight)\n            return 1;\n        const areaSize = this.horizontal ? this.$target.clientWidth : this.$target.clientHeight;\n        const scrollSize = this.horizontal ? this.$target.scrollWidth : this.$target.scrollHeight;\n        return Math.min((areaSize + 1) / scrollSize, 1);\n    }\n    /** Relative position value (between 0.0 and 1.0) */\n    get position() {\n        if (!this.$target)\n            return 0;\n        const scrollOffset = this.horizontal ? RTLUtils.normalizeScrollLeft(this.$target) : this.$target.scrollTop;\n        return this.scrollableSize ? (scrollOffset / this.scrollableSize) : 0;\n    }\n    set position(position) {\n        this.scrollTargetTo(this.scrollableSize * this.normalizePosition(position));\n        this.update();\n    }\n    /** Normalizes position value (between 0.0 and 1.0) */\n    normalizePosition(position) {\n        const relativePosition = Math.min(1, Math.max(0, position));\n        if (this.$target && !RTLUtils.isRtl(this.$target))\n            return relativePosition;\n        return RTLUtils.scrollType === 'negative' ? (relativePosition - 1) : (1 - relativePosition);\n    }\n    /** Scrolls target element to passed position */\n    scrollTargetTo(pos) {\n        if (!this.$target)\n            return;\n        this.$target.scrollTo({\n            [this.horizontal ? 'left' : 'top']: pos,\n            behavior: this.dragging ? 'auto' : 'smooth'\n        });\n    }\n    /** Updates thumb size and position */\n    update() {\n        this.$$fire('change:scroll', { bubbles: false });\n        if (!this.$scrollbarThumb || !this.$scrollbarTrack)\n            return;\n        const thumbSize = this.trackOffset * this.thumbSize;\n        const thumbPosition = (this.trackOffset - thumbSize) * this.position;\n        const style = {\n            [this.horizontal ? 'left' : 'top']: `${thumbPosition}px`,\n            [this.horizontal ? 'width' : 'height']: `${thumbSize}px`\n        };\n        Object.assign(this.$scrollbarThumb.style, style);\n    }\n    /** Updates auxiliary markers */\n    updateMarkers() {\n        const { position, thumbSize } = this;\n        this.toggleAttribute('at-start', thumbSize < 1 && position <= 0);\n        this.toggleAttribute('at-end', thumbSize < 1 && position >= 1);\n        this.toggleAttribute('inactive', thumbSize >= 1);\n    }\n    /** Refreshes scroll state and position */\n    refresh() {\n        this.update();\n        this.updateMarkers();\n    }\n    /** Returns position from MouseEvent coordinates (not normalized) */\n    toPosition(event) {\n        const { horizontal, thumbOffset, trackOffset } = this;\n        const point = EventUtils.normalizeCoordinates(event, this.$scrollbarTrack);\n        const pointPosition = horizontal ? point.x : point.y;\n        const freeTrackArea = trackOffset - thumbOffset; // size of free track px\n        const clickPositionNoOffset = pointPosition - thumbOffset / 2;\n        return clickPositionNoOffset / freeTrackArea;\n    }\n    // Event listeners\n    /** Handles `mousedown` / `touchstart` event to manage thumb drag start and scroll clicks */\n    _onPointerDown(event) {\n        this._initialPosition = this.position;\n        this._pointerPosition = this.toPosition(event);\n        const point = EventUtils.normalizeTouchPoint(event);\n        this._initialMousePosition = this.horizontal ? point.x : point.y;\n        if (event.target === this.$scrollbarThumb) {\n            this._onThumbPointerDown(event); // Drag start handler\n        }\n        else {\n            this._onPointerDownTick(true); // Continuous scroll and click handler\n        }\n        // Subscribe inverse handlers\n        EventUtils.isMouseEvent(event) && window.addEventListener('mouseup', this._onPointerUp);\n        EventUtils.isTouchEvent(event) && window.addEventListener('touchend', this._onPointerUp, { passive: false });\n        // Prevents default text selection, etc.\n        event.preventDefault();\n    }\n    /** Handles a scroll click / continuous scroll*/\n    _onPointerDownTick(first) {\n        this._scrollTimer && window.clearTimeout(this._scrollTimer);\n        const position = this.position;\n        const allowedOffset = (first ? 1 : 1.5) * this.thumbSize;\n        this.position = Math.min(position + allowedOffset, Math.max(position - allowedOffset, this._pointerPosition));\n        if (this.position === this._pointerPosition || this.noContinuousScroll)\n            return;\n        this._scrollTimer = window.setTimeout(this._onPointerDownTick, 400);\n    }\n    /** Handles thumb drag start */\n    _onThumbPointerDown(event) {\n        var _a;\n        this.toggleAttribute('dragging', true);\n        (_a = this.$target) === null || _a === void 0 ? void 0 : _a.style.setProperty('scroll-behavior', 'auto');\n        // Attach drag listeners\n        window.addEventListener('click', this._onBodyClick, { capture: true });\n        EventUtils.isMouseEvent(event) && window.addEventListener('mousemove', this._onPointerMove);\n        EventUtils.isTouchEvent(event) && window.addEventListener('touchmove', this._onPointerMove, { passive: false });\n    }\n    /** Sets position on drag */\n    _onPointerDrag(event) {\n        const point = EventUtils.normalizeTouchPoint(event);\n        const mousePosition = this.horizontal ? point.x : point.y;\n        const positionChange = mousePosition - this._initialMousePosition;\n        const scrollableAreaHeight = this.trackOffset - this.thumbOffset;\n        const absChange = scrollableAreaHeight ? (positionChange / scrollableAreaHeight) : 0;\n        this.position = this._initialPosition + absChange;\n        this.updateMarkers();\n    }\n    /** `mousemove` document handler for thumb drag event. Active only if drag action is active */\n    _onPointerMove(event) {\n        if (!this.dragging)\n            return;\n        // Request position update\n        this._deferredDrag(event);\n        // Prevents default text selection, etc.\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    /** `mouseup` short-time document handler for drag end action */\n    _onPointerUp(event) {\n        var _a;\n        this._scrollTimer && window.clearTimeout(this._scrollTimer);\n        this.toggleAttribute('dragging', false);\n        (_a = this.$target) === null || _a === void 0 ? void 0 : _a.style.removeProperty('scroll-behavior');\n        // Unbind drag listeners\n        if (EventUtils.isMouseEvent(event)) {\n            window.removeEventListener('mousemove', this._onPointerMove);\n            window.removeEventListener('mouseup', this._onPointerUp);\n        }\n        if (EventUtils.isTouchEvent(event)) {\n            window.removeEventListener('touchmove', this._onPointerMove);\n            window.removeEventListener('touchend', this._onPointerUp);\n        }\n    }\n    /** Body `click` short-time handler to prevent clicks event on thumb drag. Handles capture phase */\n    _onBodyClick(event) {\n        event.stopImmediatePropagation();\n        window.removeEventListener('click', this._onBodyClick, { capture: true });\n    }\n    /**\n     * Handler for refresh events to update the scroll.\n     * @param event - instance of 'resize' or 'scroll' or 'esl:refresh' event.\n     */\n    _onRefresh(event) {\n        const target = event.target;\n        if (event.type === 'scroll' && this.dragging)\n            return;\n        if (event.type === 'esl:refresh' && !isRelativeNode(target.parentNode, this.$target))\n            return;\n        this._deferredRefresh();\n    }\n};\nESLScrollbar.is = 'esl-scrollbar';\n__decorate([\n    boolAttr()\n], ESLScrollbar.prototype, \"horizontal\", void 0);\n__decorate([\n    boolAttr()\n], ESLScrollbar.prototype, \"noContinuousScroll\", void 0);\n__decorate([\n    attr({ defaultValue: '::parent' })\n], ESLScrollbar.prototype, \"target\", void 0);\n__decorate([\n    attr({ defaultValue: 'scrollbar-thumb' })\n], ESLScrollbar.prototype, \"thumbClass\", void 0);\n__decorate([\n    attr({ defaultValue: 'scrollbar-track' })\n], ESLScrollbar.prototype, \"trackClass\", void 0);\n__decorate([\n    boolAttr({ readonly: true })\n], ESLScrollbar.prototype, \"dragging\", void 0);\n__decorate([\n    boolAttr({ readonly: true })\n], ESLScrollbar.prototype, \"inactive\", void 0);\n__decorate([\n    boolAttr({ readonly: true })\n], ESLScrollbar.prototype, \"atStart\", void 0);\n__decorate([\n    boolAttr({ readonly: true })\n], ESLScrollbar.prototype, \"atEnd\", void 0);\n__decorate([\n    ready\n], ESLScrollbar.prototype, \"connectedCallback\", null);\n__decorate([\n    ready\n], ESLScrollbar.prototype, \"disconnectedCallback\", null);\n__decorate([\n    bind\n], ESLScrollbar.prototype, \"_onPointerDown\", null);\n__decorate([\n    bind\n], ESLScrollbar.prototype, \"_onPointerDownTick\", null);\n__decorate([\n    bind\n], ESLScrollbar.prototype, \"_onThumbPointerDown\", null);\n__decorate([\n    bind\n], ESLScrollbar.prototype, \"_onPointerMove\", null);\n__decorate([\n    bind\n], ESLScrollbar.prototype, \"_onPointerUp\", null);\n__decorate([\n    bind\n], ESLScrollbar.prototype, \"_onBodyClick\", null);\n__decorate([\n    bind\n], ESLScrollbar.prototype, \"_onRefresh\", null);\nESLScrollbar = __decorate([\n    ExportNs('Scrollbar')\n], ESLScrollbar);\nexport { ESLScrollbar };\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { ESLTrigger } from '../../esl-trigger/core';\nimport { attr } from '../../esl-base-element/decorators/attr';\n/**\n * ESlTab component\n * @author Julia Murashko\n *\n * Tab trigger item, usually used in conjunction with a {@link ESLTabs}.\n * Can control any {@link ESLToggleable} instance but is usually used in conjunction with {@link ESLPanel}\n */\nlet ESLTab = class ESLTab extends ESLTrigger {\n    initA11y() {\n        const target = this.$a11yTarget;\n        if (!target)\n            return;\n        if (target.hasAttribute('role'))\n            return;\n        target.setAttribute('role', 'tab');\n    }\n    updateA11y() {\n        const target = this.$a11yTarget;\n        if (!target)\n            return;\n        target.setAttribute('aria-selected', String(this.active));\n        target.setAttribute('tabindex', this.active ? '0' : '-1');\n        if (this.$target && this.$target.id) {\n            this.setAttribute('aria-controls', this.$target.id);\n        }\n    }\n};\nESLTab.is = 'esl-tab';\n__decorate([\n    attr({ defaultValue: 'show' })\n], ESLTab.prototype, \"mode\", void 0);\n__decorate([\n    attr({ defaultValue: 'active' })\n], ESLTab.prototype, \"activeClass\", void 0);\nESLTab = __decorate([\n    ExportNs('Tab')\n], ESLTab);\nexport { ESLTab };\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ESLTabs_1;\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { ESLBaseElement, attr } from '../../esl-base-element/core';\nimport { rafDecorator } from '../../esl-utils/async/raf';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { memoize } from '../../esl-utils/decorators/memoize';\nimport { RTLUtils } from '../../esl-utils/dom/rtl';\nimport { debounce } from '../../esl-utils/async/debounce';\nimport { CSSClassUtils } from '../../esl-utils/dom/class';\nimport { ESLMediaRuleList } from '../../esl-media-query/core/esl-media-rule-list';\nimport { ESLTab } from './esl-tab';\n/**\n * ESlTabs component\n * @author Julia Murashko\n *\n * Tabs container component for Tabs trigger group.\n * Uses {@link ESLTab} as an item.\n * Each individual {@link ESLTab} can control {@link ESLToggleable} or, usually, {@link ESLPanel}\n */\nlet ESLTabs = ESLTabs_1 = class ESLTabs extends ESLBaseElement {\n    constructor() {\n        super(...arguments);\n        this._deferredUpdateArrows = debounce(this.updateArrows, 100, this);\n        this._deferredFitToViewport = debounce(this.fitToViewport, 100, this);\n        // TODO: is the raf decorator needed?\n        this._onResize = rafDecorator(() => this._deferredFitToViewport(this.$current, 'auto'));\n    }\n    static get observedAttributes() {\n        return ['scrollable'];\n    }\n    /** ESLMediaRuleList instance of the scrollable type mapping */\n    get scrollableTypeRules() {\n        return ESLMediaRuleList.parse(this.scrollable);\n    }\n    /** @returns current scrollable type */\n    get currentScrollableType() {\n        return this.scrollableTypeRules.activeValue || '';\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.scrollableTypeRules.addListener(this._onScrollableTypeChange);\n        this.updateScrollableType();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.scrollableTypeRules.removeListener(this._onScrollableTypeChange);\n        this.unbindScrollableEvents();\n    }\n    attributeChangedCallback(attrName, oldVal, newVal) {\n        if (!this.connected || oldVal === newVal)\n            return;\n        if (attrName === 'scrollable') {\n            this.scrollableTypeRules.removeListener(this._onScrollableTypeChange);\n            memoize.clear(this, 'scrollableTypeRules');\n            this.scrollableTypeRules.addListener(this._onScrollableTypeChange);\n            this.updateScrollableType();\n        }\n    }\n    bindScrollableEvents() {\n        var _a;\n        this.addEventListener('esl:change:active', this._onTriggerStateChange);\n        this.addEventListener('click', this._onClick, false);\n        this.addEventListener('focusin', this._onFocus);\n        (_a = this.$scrollableTarget) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', this._onScroll, { passive: true });\n        window.addEventListener('resize', this._onResize);\n    }\n    unbindScrollableEvents() {\n        var _a;\n        this.removeEventListener('esl:change:active', this._onTriggerStateChange);\n        this.removeEventListener('click', this._onClick, false);\n        this.removeEventListener('focusin', this._onFocus);\n        (_a = this.$scrollableTarget) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', this._onScroll);\n        window.removeEventListener('resize', this._onResize);\n    }\n    /** Collection of inner {@link ESLTab} items */\n    get $tabs() {\n        const els = this.querySelectorAll(ESLTab.is);\n        return els ? Array.from(els) : [];\n    }\n    /** Active {@link ESLTab} item */\n    get $current() {\n        return this.$tabs.find((el) => el.active) || null;\n    }\n    /** Container element to scroll */\n    get $scrollableTarget() {\n        return this.querySelector(this.scrollableTarget);\n    }\n    /** Is the scrollable mode enabled ? */\n    get isScrollable() {\n        return this.currentScrollableType !== 'disabled';\n    }\n    /** Move scroll to the next/previous item */\n    moveTo(direction, behavior = 'smooth') {\n        const $scrollableTarget = this.$scrollableTarget;\n        if (!$scrollableTarget)\n            return;\n        let left = $scrollableTarget.offsetWidth;\n        left = RTLUtils.isRtl(this) && RTLUtils.scrollType !== 'reverse' ? -left : left;\n        left = direction === 'left' ? -left : left;\n        $scrollableTarget.scrollBy({ left, behavior });\n    }\n    /** Scroll tab to the view */\n    fitToViewport($trigger, behavior = 'smooth') {\n        this.updateMarkers();\n        const $scrollableTarget = this.$scrollableTarget;\n        if (!$scrollableTarget || !$trigger)\n            return;\n        const areaRect = $scrollableTarget.getBoundingClientRect();\n        const itemRect = $trigger.getBoundingClientRect();\n        $scrollableTarget.scrollBy({\n            left: this.calcScrollOffset(itemRect, areaRect),\n            behavior\n        });\n        this.updateArrows();\n    }\n    /** Get scroll offset position from the selected item rectangle */\n    calcScrollOffset(itemRect, areaRect) {\n        const isReversedRTL = RTLUtils.isRtl(this) && RTLUtils.scrollType === 'reverse';\n        if (this.currentScrollableType === 'center') {\n            const shift = itemRect.left + itemRect.width / 2 - (areaRect.left + areaRect.width / 2);\n            return isReversedRTL ? -shift : shift;\n        }\n        // item is out of area from the right side\n        // else item out is of area from the left side\n        if (itemRect.right > areaRect.right) {\n            return isReversedRTL ? Math.floor(areaRect.right - itemRect.right) : Math.ceil(itemRect.right - areaRect.right);\n        }\n        else if (itemRect.left < areaRect.left) {\n            return isReversedRTL ? Math.ceil(areaRect.left - itemRect.left) : Math.floor(itemRect.left - areaRect.left);\n        }\n    }\n    updateArrows() {\n        const $scrollableTarget = this.$scrollableTarget;\n        if (!$scrollableTarget)\n            return;\n        const swapSides = RTLUtils.isRtl(this) && RTLUtils.scrollType === 'default';\n        const scrollStart = Math.abs($scrollableTarget.scrollLeft) > 1;\n        const scrollEnd = Math.abs($scrollableTarget.scrollLeft) + $scrollableTarget.clientWidth + 1 < $scrollableTarget.scrollWidth;\n        const $rightArrow = this.querySelector('[data-tab-direction=\"right\"]');\n        const $leftArrow = this.querySelector('[data-tab-direction=\"left\"]');\n        $leftArrow && $leftArrow.toggleAttribute('disabled', !(swapSides ? scrollEnd : scrollStart));\n        $rightArrow && $rightArrow.toggleAttribute('disabled', !(swapSides ? scrollStart : scrollEnd));\n    }\n    updateMarkers() {\n        const $scrollableTarget = this.$scrollableTarget;\n        if (!$scrollableTarget)\n            return;\n        const hasScroll = this.isScrollable && ($scrollableTarget.scrollWidth > this.clientWidth);\n        this.toggleAttribute('has-scroll', hasScroll);\n    }\n    /** Update element state according to scrollable type */\n    updateScrollableType() {\n        ESLTabs_1.supportedScrollableTypes.forEach((type) => {\n            CSSClassUtils.toggle(this, `${type}-alignment`, this.currentScrollableType === type);\n        });\n        this._deferredFitToViewport(this.$current);\n        if (this.currentScrollableType === 'disabled') {\n            this.unbindScrollableEvents();\n        }\n        else {\n            this.bindScrollableEvents();\n        }\n    }\n    _onTriggerStateChange({ detail }) {\n        if (!detail.active)\n            return;\n        this._deferredFitToViewport(this.$current);\n    }\n    _onClick(event) {\n        const eventTarget = event.target;\n        const target = eventTarget.closest('[data-tab-direction]');\n        const direction = target && target.dataset.tabDirection;\n        if (!direction)\n            return;\n        this.moveTo(direction);\n    }\n    _onFocus(e) {\n        const target = e.target;\n        if (target instanceof ESLTab)\n            this._deferredFitToViewport(target);\n    }\n    _onScroll() {\n        this._deferredUpdateArrows();\n    }\n    /** Handles scrollable type change */\n    _onScrollableTypeChange() {\n        this.updateScrollableType();\n    }\n};\nESLTabs.is = 'esl-tabs';\n/** List of supported scrollable types */\nESLTabs.supportedScrollableTypes = ['disabled', 'side', 'center'];\n__decorate([\n    attr({ defaultValue: 'disabled' })\n], ESLTabs.prototype, \"scrollable\", void 0);\n__decorate([\n    attr({ defaultValue: '.esl-tab-container' })\n], ESLTabs.prototype, \"scrollableTarget\", void 0);\n__decorate([\n    memoize()\n], ESLTabs.prototype, \"scrollableTypeRules\", null);\n__decorate([\n    bind\n], ESLTabs.prototype, \"_onTriggerStateChange\", null);\n__decorate([\n    bind\n], ESLTabs.prototype, \"_onClick\", null);\n__decorate([\n    bind\n], ESLTabs.prototype, \"_onFocus\", null);\n__decorate([\n    bind\n], ESLTabs.prototype, \"_onScroll\", null);\n__decorate([\n    bind\n], ESLTabs.prototype, \"_onScrollableTypeChange\", null);\nESLTabs = ESLTabs_1 = __decorate([\n    ExportNs('Tabs')\n], ESLTabs);\nexport { ESLTabs };\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ESLBaseElement } from '../../esl-base-element/core';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { EventUtils } from '../../esl-utils/dom/events';\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { ESLToggleable } from './esl-toggleable';\n/**\n * ESLToggleableDispatcher\n * @author Julia Murashko, Alexey Stsefanovich (ala'n)\n *\n * ESLToggleableDispatcher - plugin component, that prevents activation of multiple ESLToggleable instances in bounds of managed container.\n */\nlet ESLToggleableDispatcher = class ESLToggleableDispatcher extends ESLBaseElement {\n    constructor() {\n        super(...arguments);\n        this._popups = new Map();\n    }\n    /**\n     * Initialize ToggleableGroupDispatcher\n     * Uses esl-toggleable-dispatcher tag and document body root by default\n     */\n    static init(root = document.body, tagName = this.is) {\n        if (!root)\n            throw new Error('Root element should be specified');\n        const instances = root.getElementsByTagName(tagName);\n        if (instances.length)\n            return;\n        this.register(tagName);\n        root.insertAdjacentElement('afterbegin', document.createElement(tagName));\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.root = this.parentElement;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.root = null;\n    }\n    bindEvents() {\n        if (!this.root)\n            return;\n        this.root.addEventListener('esl:before:show', this._onBeforeShow);\n        this.root.addEventListener('esl:show', this._onShow);\n        this.root.addEventListener('esl:hide', this._onHide);\n        this.root.addEventListener('esl:change:group', this._onChangeGroup);\n    }\n    unbindEvents() {\n        if (!this.root)\n            return;\n        this.root.removeEventListener('esl:before:show', this._onBeforeShow);\n        this.root.removeEventListener('esl:show', this._onShow);\n        this.root.removeEventListener('esl:hide', this._onHide);\n        this.root.removeEventListener('esl:change:group', this._onChangeGroup);\n    }\n    /** Observed element */\n    get root() {\n        return this._root;\n    }\n    set root(root) {\n        this.unbindEvents();\n        this._root = root;\n        this.bindEvents();\n    }\n    /** Guard-condition for targets */\n    isAcceptable(target) {\n        if (!(target instanceof ESLToggleable))\n            return false;\n        return !!target.groupName && target.groupName !== 'none';\n    }\n    /** Hide active element in group */\n    hideActive(groupName, activator) {\n        const active = this.getActive(groupName);\n        if (!active || active === activator)\n            return;\n        active.hide({\n            initiator: 'dispatcher',\n            dispatcher: this,\n            activator\n        });\n    }\n    /** Set active element in group */\n    setActive(groupName, popup) {\n        if (!groupName)\n            return;\n        this.hideActive(groupName, popup);\n        this._popups.set(groupName, popup);\n    }\n    /** Get active element in group or undefined if group doesn't exist */\n    getActive(groupName) {\n        return this._popups.get(groupName);\n    }\n    /** Delete element from the group if passed element is currently active */\n    deleteActive(groupName, popup) {\n        if (this.getActive(groupName) !== popup)\n            return;\n        this._popups.delete(groupName);\n    }\n    /** Hide active element before e.target will be shown */\n    _onBeforeShow(e) {\n        const target = EventUtils.source(e);\n        if (!this.isAcceptable(target))\n            return;\n        this.hideActive(target.groupName, target);\n    }\n    /** Update active element after a new element is shown */\n    _onShow(e) {\n        const target = EventUtils.source(e);\n        if (!this.isAcceptable(target))\n            return;\n        this.setActive(target.groupName, target);\n    }\n    /** Update group state after active element is hidden */\n    _onHide(e) {\n        const target = EventUtils.source(e);\n        if (!this.isAcceptable(target))\n            return;\n        this.deleteActive(target.groupName, target);\n    }\n    /** Update active elements */\n    _onChangeGroup(e) {\n        const target = EventUtils.source(e);\n        if (!this.isAcceptable(target))\n            return;\n        const { oldGroupName, newGroupName } = e.detail;\n        this.deleteActive(oldGroupName, target);\n        this.setActive(newGroupName, target);\n    }\n};\nESLToggleableDispatcher.is = 'esl-toggleable-dispatcher';\n__decorate([\n    bind\n], ESLToggleableDispatcher.prototype, \"_onBeforeShow\", null);\n__decorate([\n    bind\n], ESLToggleableDispatcher.prototype, \"_onShow\", null);\n__decorate([\n    bind\n], ESLToggleableDispatcher.prototype, \"_onHide\", null);\n__decorate([\n    bind\n], ESLToggleableDispatcher.prototype, \"_onChangeGroup\", null);\nESLToggleableDispatcher = __decorate([\n    ExportNs('ToggleableDispatcher')\n], ESLToggleableDispatcher);\nexport { ESLToggleableDispatcher };\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ESLToggleable_1;\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { ESC, SYSTEM_KEYS } from '../../esl-utils/dom/keys';\nimport { CSSClassUtils } from '../../esl-utils/dom/class';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { defined, copyDefinedKeys } from '../../esl-utils/misc/object';\nimport { sequentialUID } from '../../esl-utils/misc/uid';\nimport { DeviceDetector } from '../../esl-utils/environment/device-detector';\nimport { DelayedTask } from '../../esl-utils/async/delayed-task';\nimport { ESLBaseElement, attr, jsonAttr, boolAttr } from '../../esl-base-element/core';\nconst activators = new WeakMap();\n/**\n * ESLToggleable component\n * @author Julia Murashko, Alexey Stsefanovich (ala'n)\n *\n * ESLToggleable - a custom element, that is used as a base for \"Popup-like\" components creation\n */\nlet ESLToggleable = ESLToggleable_1 = class ESLToggleable extends ESLBaseElement {\n    constructor() {\n        super(...arguments);\n        /** Inner state */\n        this._open = false;\n        /** Inner show/hide task manager instance */\n        this._task = new DelayedTask();\n        /** Marker for current hover listener state */\n        this._trackHover = false;\n    }\n    static get observedAttributes() {\n        return ['open', 'group'];\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (!this.id && !this.noAutoId) {\n            const tag = this.constructor.is;\n            this.id = sequentialUID(tag, tag + '-');\n        }\n        this.initiallyOpened = this.hasAttribute('open');\n        this.bindEvents();\n        this.setInitialState();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.unbindEvents();\n        activators.delete(this);\n    }\n    attributeChangedCallback(attrName, oldVal, newVal) {\n        if (!this.connected || newVal === oldVal)\n            return;\n        switch (attrName) {\n            case 'open':\n                if (this.open === this.hasAttribute('open'))\n                    return;\n                this.toggle(this.open, { initiator: 'attribute', showDelay: 0, hideDelay: 0 });\n                break;\n            case 'group':\n                this.$$fire('change:group', {\n                    detail: { oldGroupName: oldVal, newGroupName: newVal }\n                });\n                break;\n        }\n    }\n    /** Set initial state of the Toggleable */\n    setInitialState() {\n        if (this.initialParams) {\n            this.toggle(this.initiallyOpened, this.initialParams);\n        }\n    }\n    bindEvents() {\n        this.addEventListener('click', this._onClick);\n        this.addEventListener('keydown', this._onKeyboardEvent);\n        this.addEventListener('esl:show:request', this._onShowRequest);\n    }\n    unbindEvents() {\n        this.removeEventListener('click', this._onClick);\n        this.removeEventListener('keydown', this._onKeyboardEvent);\n        this.removeEventListener('esl:show:request', this._onShowRequest);\n        this.bindOutsideEventTracking(false);\n        this.bindHoverStateTracking(false);\n    }\n    /** Bind outside action event listeners */\n    bindOutsideEventTracking(track) {\n        document.body.removeEventListener('keydown', this._onOutsideAction, true);\n        document.body.removeEventListener('mouseup', this._onOutsideAction, true);\n        document.body.removeEventListener('touchend', this._onOutsideAction, true);\n        if (track) {\n            document.body.addEventListener('keydown', this._onOutsideAction, true);\n            document.body.addEventListener('mouseup', this._onOutsideAction, true);\n            document.body.addEventListener('touchend', this._onOutsideAction, true);\n        }\n    }\n    /** Bind hover events listeners for the Toggleable itself */\n    bindHoverStateTracking(track, hideDelay) {\n        if (!DeviceDetector.hasHover)\n            return;\n        this._trackHoverDelay = track && hideDelay !== undefined ? +hideDelay : undefined;\n        if (this._trackHover === track)\n            return;\n        this._trackHover = track;\n        this.removeEventListener('mouseenter', this._onMouseEnter);\n        this.removeEventListener('mouseleave', this._onMouseLeave);\n        if (this._trackHover) {\n            this.addEventListener('mouseenter', this._onMouseEnter);\n            this.addEventListener('mouseleave', this._onMouseLeave);\n        }\n    }\n    /** Function to merge the result action params */\n    mergeDefaultParams(params) {\n        return Object.assign({}, this.defaultParams, copyDefinedKeys(params));\n    }\n    /** Toggle the element state */\n    toggle(state = !this.open, params) {\n        return state ? this.show(params) : this.hide(params);\n    }\n    /** Change the element state to active */\n    show(params) {\n        params = this.mergeDefaultParams(params);\n        this._task.put(this.showTask.bind(this, params), defined(params.showDelay, params.delay));\n        this.bindOutsideEventTracking(this.closeOnOutsideAction);\n        this.bindHoverStateTracking(!!params.trackHover, defined(params.hideDelay, params.delay));\n        return this;\n    }\n    /** Change the element state to inactive */\n    hide(params) {\n        params = this.mergeDefaultParams(params);\n        this._task.put(this.hideTask.bind(this, params), defined(params.hideDelay, params.delay));\n        this.bindOutsideEventTracking(false);\n        this.bindHoverStateTracking(!!params.trackHover, defined(params.hideDelay, params.delay));\n        return this;\n    }\n    /** Actual show task to execute by toggleable task manger ({@link DelayedTask} out of the box) */\n    showTask(params) {\n        if (!params.force && this.open)\n            return;\n        if (!params.silent && !this.$$fire('before:show', { detail: { params } }))\n            return;\n        this.activator = params.activator;\n        this.open = true;\n        this.onShow(params);\n        if (!params.silent)\n            this.$$fire('show', { detail: { params }, cancelable: false });\n    }\n    /** Actual hide task to execute by toggleable task manger ({@link DelayedTask} out of the box) */\n    hideTask(params) {\n        if (!params.force && !this.open)\n            return;\n        if (!params.silent && !this.$$fire('before:hide', { detail: { params } }))\n            return;\n        this.open = false;\n        this.onHide(params);\n        this.bindOutsideEventTracking(false);\n        if (!params.silent)\n            this.$$fire('hide', { detail: { params }, cancelable: false });\n    }\n    /**\n     * Actions to execute on show toggleable.\n     * Inner state and 'open' attribute are not affected and updated before `onShow` execution.\n     * Adds CSS classes, update a11y and fire esl:refresh event by default.\n     */\n    onShow(params) {\n        CSSClassUtils.add(this, this.activeClass);\n        CSSClassUtils.add(document.body, this.bodyClass, this);\n        this.updateA11y();\n        this.$$fire('esl:refresh'); // To notify other components about content change\n    }\n    /**\n     * Actions to execute on hide toggleable.\n     * Inner state and 'open' attribute are not affected and updated before `onShow` execution.\n     * Removes CSS classes and update a11y by default.\n     */\n    onHide(params) {\n        CSSClassUtils.remove(this, this.activeClass);\n        CSSClassUtils.remove(document.body, this.bodyClass, this);\n        this.updateA11y();\n    }\n    /** Active state marker */\n    get open() {\n        return this._open;\n    }\n    set open(value) {\n        this.toggleAttribute('open', this._open = value);\n    }\n    /** Last component that has activated the element. Uses {@link ToggleableActionParams.activator}*/\n    get activator() {\n        return activators.get(this);\n    }\n    set activator(el) {\n        el ? activators.set(this, el) : activators.delete(this);\n    }\n    /** Returns the element to apply a11y attributes */\n    get $a11yTarget() {\n        const target = this.getAttribute('a11y-target');\n        if (target === 'none')\n            return null;\n        return target ? this.querySelector(target) : this;\n    }\n    /** Called on show and on hide actions to update a11y state accordingly */\n    updateA11y() {\n        const targetEl = this.$a11yTarget;\n        if (!targetEl)\n            return;\n        targetEl.setAttribute('aria-hidden', String(!this._open));\n    }\n    /** @returns if the passed event should trigger hide action */\n    isOutsideAction(e) {\n        const target = e.target;\n        // target is inside current toggleable\n        if (this.contains(target))\n            return false;\n        // target is inside last activator\n        if (this.activator && this.activator.contains(target))\n            return false;\n        // Event is not a system command key\n        return !(e instanceof KeyboardEvent && SYSTEM_KEYS.includes(e.key));\n    }\n    _onClick(e) {\n        const target = e.target;\n        if (this.closeTrigger && target.closest(this.closeTrigger)) {\n            this.hide({ initiator: 'close', activator: target, event: e });\n        }\n    }\n    _onOutsideAction(e) {\n        if (!this.isOutsideAction(e))\n            return;\n        // Used 0 delay to decrease priority of the request\n        this.hide({ initiator: 'outsideaction', hideDelay: 0, event: e });\n    }\n    _onKeyboardEvent(e) {\n        if (this.closeOnEsc && e.key === ESC) {\n            this.hide({ initiator: 'keyboard', event: e });\n        }\n    }\n    _onMouseEnter(e) {\n        const hideDelay = this._trackHoverDelay;\n        const baseParams = { initiator: 'mouseenter', trackHover: true, activator: this.activator, event: e, hideDelay };\n        this.show(Object.assign(baseParams, this.trackHoverParams));\n    }\n    _onMouseLeave(e) {\n        const hideDelay = this._trackHoverDelay;\n        const baseParams = { initiator: 'mouseleave', trackHover: true, activator: this.activator, event: e, hideDelay };\n        this.hide(Object.assign(baseParams, this.trackHoverParams));\n    }\n    /** Actions to execute on show request */\n    _onShowRequest() {\n        this.show();\n    }\n};\nESLToggleable.is = 'esl-toggleable';\n__decorate([\n    attr()\n], ESLToggleable.prototype, \"bodyClass\", void 0);\n__decorate([\n    attr({ defaultValue: 'open' })\n], ESLToggleable.prototype, \"activeClass\", void 0);\n__decorate([\n    attr({ name: 'group' })\n], ESLToggleable.prototype, \"groupName\", void 0);\n__decorate([\n    attr({ name: 'close-on' })\n], ESLToggleable.prototype, \"closeTrigger\", void 0);\n__decorate([\n    boolAttr()\n], ESLToggleable.prototype, \"noAutoId\", void 0);\n__decorate([\n    boolAttr()\n], ESLToggleable.prototype, \"closeOnEsc\", void 0);\n__decorate([\n    boolAttr()\n], ESLToggleable.prototype, \"closeOnOutsideAction\", void 0);\n__decorate([\n    jsonAttr({ defaultValue: { force: true, initiator: 'init' } })\n], ESLToggleable.prototype, \"initialParams\", void 0);\n__decorate([\n    jsonAttr({ defaultValue: {} })\n], ESLToggleable.prototype, \"defaultParams\", void 0);\n__decorate([\n    jsonAttr({ defaultValue: {} })\n], ESLToggleable.prototype, \"trackHoverParams\", void 0);\n__decorate([\n    bind\n], ESLToggleable.prototype, \"_onClick\", null);\n__decorate([\n    bind\n], ESLToggleable.prototype, \"_onOutsideAction\", null);\n__decorate([\n    bind\n], ESLToggleable.prototype, \"_onKeyboardEvent\", null);\n__decorate([\n    bind\n], ESLToggleable.prototype, \"_onMouseEnter\", null);\n__decorate([\n    bind\n], ESLToggleable.prototype, \"_onMouseLeave\", null);\n__decorate([\n    bind\n], ESLToggleable.prototype, \"_onShowRequest\", null);\nESLToggleable = ESLToggleable_1 = __decorate([\n    ExportNs('Toggleable')\n], ESLToggleable);\nexport { ESLToggleable };\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar TraversingQuery_1;\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { tuple, wrap, uniq } from '../../esl-utils/misc/array';\nimport { unwrapParenthesis } from '../../esl-utils/misc/format';\nimport { findAll, findChildren, findNext, findParent, findPrev } from '../../esl-utils/dom/traversing';\n/**\n * Traversing Query utility to find element via extended selector query\n * Extended query supports\n * - plain CSS selectors\n * - relative selectors (selectors that don't start from a plain selector will use passed base Element as a root)\n * - ::next and ::prev sibling pseudo-selectors\n * - ::parent and ::child pseudo-selectors\n * - ::find pseudo-selector\n * - ::first, ::last and :nth(#) limitation pseudo-selectors\n * - ::filter, ::not filtration pseudo-selectors\n *\n * @example\n * - `#id .class [attr]` - find by CSS selector in a current document\n * - ` ` - get current base element\n * - `::next` - get next sibling element\n * - `::prev` - get previous sibling element\n * - `::parent` - get base element parent\n * - `::parent(#id .class [attr])` - find the closest parent matching passed selector\n * - `::child(#id .class [attr])` - find direct child element(s) that match passed selector\n * - `::find(#id .class [attr])` - find child element(s) that match passed selector\n * - `::find(buttons, a)::not([hidden])` - find all buttons and anchors that are not have hidden attribute\n * - `::find(buttons, a)::filter(:first-child)` - find all buttons and anchors that are first child in container\n * - `::parent::child(some-tag)` - find direct child element(s) that match tag 'some-tag' in the parent\n * - `#id .class [attr]::parent` - find parent of element matching selector '#id .class [attr]' in document\n * - `::find(.row)::last::parent` - find parent of the last element matching selector '.row' from the base element subtree\n */\nlet TraversingQuery = TraversingQuery_1 = class TraversingQuery {\n    /**\n     * @returns RegExp that selects all known processors in query string\n     * e.g. /(::parent|::child|::next|::prev)/\n     */\n    static get PROCESSORS_REGEX() {\n        const keys = Object.keys(this.ELEMENT_PROCESSORS).concat(Object.keys(this.COLLECTION_PROCESSORS));\n        return new RegExp(`(${keys.join('|')})`, 'g');\n    }\n    static isCollectionProcessor([name]) {\n        return !!name && (name in this.COLLECTION_PROCESSORS);\n    }\n    static processElement(el, [name, selString]) {\n        const sel = unwrapParenthesis(selString || '');\n        if (!name || !(name in this.ELEMENT_PROCESSORS))\n            return [];\n        return wrap(this.ELEMENT_PROCESSORS[name](el, sel));\n    }\n    static processCollection(els, [name, selString]) {\n        const sel = unwrapParenthesis(selString || '');\n        if (!name || !(name in this.COLLECTION_PROCESSORS))\n            return [];\n        return wrap(this.COLLECTION_PROCESSORS[name](els, sel));\n    }\n    static traverseChain(collection, processors, findFirst) {\n        if (!processors.length || !collection.length)\n            return collection;\n        const [processor, ...rest] = processors;\n        if (this.isCollectionProcessor(processor)) {\n            const processedItem = this.processCollection(collection, processor);\n            return this.traverseChain(processedItem, rest, findFirst);\n        }\n        const result = [];\n        for (const target of collection) {\n            const processedItem = this.processElement(target, processor);\n            const resultCollection = this.traverseChain(processedItem, rest, findFirst);\n            if (!resultCollection.length)\n                continue;\n            if (findFirst)\n                return resultCollection.slice(0, 1);\n            result.push(...resultCollection);\n        }\n        return uniq(result);\n    }\n    static traverse(query, findFirst, base, scope = document) {\n        const parts = query.split(this.PROCESSORS_REGEX).map((term) => term.trim());\n        const rootSel = parts.shift();\n        const baseCollection = base ? [base] : [];\n        const initial = rootSel ? Array.from(scope.querySelectorAll(rootSel)) : baseCollection;\n        return this.traverseChain(initial, tuple(parts), findFirst);\n    }\n    /** @returns first matching element reached via {@link TraversingQuery} rules */\n    static first(query, base, scope) {\n        return TraversingQuery_1.traverse(query, true, base, scope)[0] || null;\n    }\n    /** @returns Array of all matching elements reached via {@link TraversingQuery} rules */\n    static all(query, base, scope) {\n        return TraversingQuery_1.traverse(query, false, base, scope);\n    }\n};\nTraversingQuery.ELEMENT_PROCESSORS = {\n    '::find': findAll,\n    '::next': findNext,\n    '::prev': findPrev,\n    '::child': findChildren,\n    '::parent': findParent\n};\nTraversingQuery.COLLECTION_PROCESSORS = {\n    '::first': (list) => list.slice(0, 1),\n    '::last': (list) => list.slice(-1),\n    '::nth': (list, sel) => {\n        const index = sel ? +sel : NaN;\n        return wrap(list[index - 1]);\n    },\n    '::not': (list, sel) => list.filter((el) => !el.matches(sel || '')),\n    '::filter': (list, sel) => list.filter((el) => el.matches(sel || ''))\n};\nTraversingQuery = TraversingQuery_1 = __decorate([\n    ExportNs('TraversingQuery')\n], TraversingQuery);\nexport { TraversingQuery };\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ExportNs } from '../../esl-utils/environment/export-ns';\nimport { attr, boolAttr, ESLBaseElement } from '../../esl-base-element/core';\nimport { bind } from '../../esl-utils/decorators/bind';\nimport { ready } from '../../esl-utils/decorators/ready';\nimport { parseNumber } from '../../esl-utils/misc/format';\nimport { CSSClassUtils } from '../../esl-utils/dom/class';\nimport { ENTER, SPACE } from '../../esl-utils/dom/keys';\nimport { TraversingQuery } from '../../esl-traversing-query/core';\nimport { DeviceDetector } from '../../esl-utils/environment/device-detector';\nimport { ESLMediaQuery } from '../../esl-media-query/core';\nlet ESLTrigger = class ESLTrigger extends ESLBaseElement {\n    static get observedAttributes() {\n        return ['target'];\n    }\n    attributeChangedCallback(attrName) {\n        if (!this.connected)\n            return;\n        if (attrName === 'target')\n            return this.updateTargetFromSelector();\n    }\n    /** Target observable Toggleable */\n    get $target() {\n        return this._$target;\n    }\n    set $target(newPopupInstance) {\n        this.unbindEvents();\n        this._$target = newPopupInstance;\n        this.bindEvents();\n        this._onTargetStateChange();\n    }\n    /** Element target to setup aria attributes */\n    get $a11yTarget() {\n        return this.a11yTarget ? this.querySelector(this.a11yTarget) : this;\n    }\n    /** Marker to allow track hover */\n    get allowHover() {\n        return DeviceDetector.hasHover && ESLMediaQuery.for(this.trackHover).matches;\n    }\n    /** Marker to allow track clicks */\n    get allowClick() {\n        return ESLMediaQuery.for(this.trackClick).matches;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.updateTargetFromSelector();\n        this.initA11y();\n    }\n    disconnectedCallback() {\n        this.unbindEvents();\n    }\n    bindEvents() {\n        if (!this.$target)\n            return;\n        this.$target.addEventListener('esl:show', this._onTargetStateChange);\n        this.$target.addEventListener('esl:hide', this._onTargetStateChange);\n        this.addEventListener('click', this._onClick);\n        this.addEventListener('keydown', this._onKeydown);\n        this.addEventListener('mouseenter', this._onMouseEnter);\n        this.addEventListener('mouseleave', this._onMouseLeave);\n    }\n    unbindEvents() {\n        if (!this.$target)\n            return;\n        this.$target.removeEventListener('esl:show', this._onTargetStateChange);\n        this.$target.removeEventListener('esl:hide', this._onTargetStateChange);\n        this.removeEventListener('click', this._onClick);\n        this.removeEventListener('keydown', this._onKeydown);\n        this.removeEventListener('mouseenter', this._onMouseEnter);\n        this.removeEventListener('mouseleave', this._onMouseLeave);\n    }\n    /** Update `$target` Toggleable  from `target` selector */\n    updateTargetFromSelector() {\n        if (!this.target)\n            return;\n        this.$target = TraversingQuery.first(this.target, this);\n    }\n    /** Check if the event target should be ignored */\n    isTargetIgnored(target) {\n        if (!target || !(target instanceof HTMLElement) || !this.ignore)\n            return false;\n        const $ignore = target.closest(this.ignore);\n        // Ignore only inner elements (but do not ignore the trigger itself)\n        return !!$ignore && $ignore !== this && this.contains($ignore);\n    }\n    /** Merge params to pass to the toggleable */\n    mergeToggleableParams(...params) {\n        return Object.assign({\n            initiator: 'trigger',\n            activator: this\n        }, ...params);\n    }\n    /** Show target toggleable with passed params */\n    showTarget(params = {}) {\n        const actionParams = this.mergeToggleableParams({\n            delay: parseNumber(this.showDelay)\n        }, params);\n        if (this.$target && typeof this.$target.show === 'function') {\n            this.$target.show(actionParams);\n        }\n    }\n    /** Hide target toggleable with passed params */\n    hideTarget(params = {}) {\n        const actionParams = this.mergeToggleableParams({\n            delay: parseNumber(this.hideDelay)\n        }, params);\n        if (this.$target && typeof this.$target.hide === 'function') {\n            this.$target.hide(actionParams);\n        }\n    }\n    /** Toggles target toggleable with passed params */\n    toggleTarget(params = {}, state = !this.active) {\n        state ? this.showTarget(params) : this.hideTarget(params);\n    }\n    /**\n     * Updates trigger state according to toggleable state\n     * Does not produce `esl:change:active` event\n     */\n    updateState() {\n        var _a;\n        const isActive = !!((_a = this.$target) === null || _a === void 0 ? void 0 : _a.open);\n        const wasActive = this.active;\n        this.toggleAttribute('active', isActive);\n        const clsTarget = TraversingQuery.first(this.activeClassTarget, this);\n        clsTarget && CSSClassUtils.toggle(clsTarget, this.activeClass, isActive);\n        this.updateA11y();\n        return isActive !== wasActive;\n    }\n    /** Handles ESLToggleable state change */\n    _onTargetStateChange(originalEvent) {\n        if (!this.updateState())\n            return;\n        const detail = { active: this.active, originalEvent };\n        this.$$fire('change:active', { detail });\n    }\n    /** Handles `click` event */\n    _onClick(event) {\n        if (!this.allowClick || this.isTargetIgnored(event.target))\n            return;\n        event.preventDefault();\n        switch (this.mode) {\n            case 'show':\n                return this.showTarget({ event });\n            case 'hide':\n                return this.hideTarget({ event });\n            default:\n                return this.toggleTarget({ event });\n        }\n    }\n    /** Handles `keydown` event */\n    _onKeydown(event) {\n        if (![ENTER, SPACE].includes(event.key) || this.isTargetIgnored(event.target))\n            return;\n        event.preventDefault();\n        switch (this.mode) {\n            case 'show':\n                return this.showTarget({ event });\n            case 'hide':\n                return this.hideTarget({ event });\n            default:\n                return this.toggleTarget({ event });\n        }\n    }\n    /** Handles hover `mouseenter` event */\n    _onMouseEnter(event) {\n        if (!this.allowHover)\n            return;\n        const delay = parseNumber(this.hoverShowDelay);\n        this.toggleTarget({ event, delay }, this.mode !== 'hide');\n        event.preventDefault();\n    }\n    /** Handles hover `mouseleave` event */\n    _onMouseLeave(event) {\n        if (!this.allowHover)\n            return;\n        if (this.mode === 'show' || this.mode === 'hide')\n            return;\n        const delay = parseNumber(this.hoverHideDelay);\n        this.hideTarget({ event, delay, trackHover: true });\n        event.preventDefault();\n    }\n    /** Set initial a11y attributes. Do nothing if trigger contains actionable element */\n    initA11y() {\n        if (this.$a11yTarget !== this)\n            return;\n        if (!this.hasAttribute('role'))\n            this.setAttribute('role', 'button');\n        if (this.getAttribute('role') === 'button' && !this.hasAttribute('tabindex')) {\n            this.setAttribute('tabindex', '0');\n        }\n    }\n    /** Update aria attributes */\n    updateA11y() {\n        const target = this.$a11yTarget;\n        if (!target)\n            return;\n        target.setAttribute('aria-expanded', String(this.active));\n        if (this.$target && this.$target.id) {\n            target.setAttribute('aria-controls', this.$target.id);\n        }\n    }\n};\nESLTrigger.is = 'esl-trigger';\n__decorate([\n    boolAttr({ readonly: true })\n], ESLTrigger.prototype, \"active\", void 0);\n__decorate([\n    attr({ defaultValue: '' })\n], ESLTrigger.prototype, \"activeClass\", void 0);\n__decorate([\n    attr({ defaultValue: '' })\n], ESLTrigger.prototype, \"activeClassTarget\", void 0);\n__decorate([\n    attr({ defaultValue: 'a[href]' })\n], ESLTrigger.prototype, \"ignore\", void 0);\n__decorate([\n    attr({ defaultValue: '::next' })\n], ESLTrigger.prototype, \"target\", void 0);\n__decorate([\n    attr({ defaultValue: 'toggle' })\n], ESLTrigger.prototype, \"mode\", void 0);\n__decorate([\n    attr({ defaultValue: 'all' })\n], ESLTrigger.prototype, \"trackClick\", void 0);\n__decorate([\n    attr({ defaultValue: 'not all' })\n], ESLTrigger.prototype, \"trackHover\", void 0);\n__decorate([\n    attr({ defaultValue: '' })\n], ESLTrigger.prototype, \"a11yTarget\", void 0);\n__decorate([\n    attr({ defaultValue: 'none' })\n], ESLTrigger.prototype, \"showDelay\", void 0);\n__decorate([\n    attr({ defaultValue: 'none' })\n], ESLTrigger.prototype, \"hideDelay\", void 0);\n__decorate([\n    attr({ defaultValue: '0' })\n], ESLTrigger.prototype, \"hoverShowDelay\", void 0);\n__decorate([\n    attr({ defaultValue: '0' })\n], ESLTrigger.prototype, \"hoverHideDelay\", void 0);\n__decorate([\n    ready\n], ESLTrigger.prototype, \"connectedCallback\", null);\n__decorate([\n    ready\n], ESLTrigger.prototype, \"disconnectedCallback\", null);\n__decorate([\n    bind\n], ESLTrigger.prototype, \"_onTargetStateChange\", null);\n__decorate([\n    bind\n], ESLTrigger.prototype, \"_onClick\", null);\n__decorate([\n    bind\n], ESLTrigger.prototype, \"_onKeydown\", null);\n__decorate([\n    bind\n], ESLTrigger.prototype, \"_onMouseEnter\", null);\n__decorate([\n    bind\n], ESLTrigger.prototype, \"_onMouseLeave\", null);\nESLTrigger = __decorate([\n    ExportNs('Trigger')\n], ESLTrigger);\nexport { ESLTrigger };\n","/**\n * Abstract Observable implementation\n * @author Yuliya Adamskaya\n */\nexport class Observable {\n    constructor() {\n        this._listeners = new Set();\n    }\n    addListener(listener) {\n        this._listeners.add(listener);\n    }\n    removeListener(listener) {\n        this._listeners.delete(listener);\n    }\n    fire(...args) {\n        this._listeners.forEach((listener) => {\n            try {\n                listener.apply(this, args);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        });\n    }\n}\n","import { createDeferred } from './promise';\n/**\n * Creates a debounced function that implements {@link Debounced}.\n * Debounced function delays invoking func until after wait milliseconds have elapsed\n * since the last time the debounced function was invoked.\n * The func is invoked with the last arguments provided to the debounced function.\n * @param fn - function to decorate\n * @param wait - time to debounce\n * @param thisArg - optional context to call original function, use debounced method call context if not defined\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function debounce(fn, wait = 10, thisArg) {\n    let timeout = null;\n    let deferred = null;\n    function debouncedSubject(...args) {\n        deferred = deferred || createDeferred();\n        (typeof timeout === 'number') && clearTimeout(timeout);\n        timeout = window.setTimeout(() => {\n            timeout = null;\n            // fn.apply to save call context\n            deferred.resolve(fn.apply(thisArg || this, args));\n            deferred = null;\n        }, wait);\n    }\n    function cancel() {\n        (typeof timeout === 'number') && clearTimeout(timeout);\n        timeout = null;\n        deferred === null || deferred === void 0 ? void 0 : deferred.reject();\n        deferred = null;\n    }\n    Object.defineProperty(debouncedSubject, 'promise', {\n        get: () => deferred ? deferred.promise : Promise.resolve()\n    });\n    Object.defineProperty(debouncedSubject, 'cancel', {\n        writable: false,\n        enumerable: false,\n        value: cancel\n    });\n    return debouncedSubject;\n}\n","/**\n * Task placeholder with a single place for executing deferred task.\n * Only one task can be planed per DelayedTask instance.\n * @see put DelayedTask.put behaviour description.\n */\nexport class DelayedTask {\n    constructor() {\n        this._fn = null;\n        this._timeout = null;\n        /** Execute deferred task immediately */\n        this.run = () => {\n            this._timeout = null;\n            this._fn && this._fn();\n        };\n    }\n    /** @returns Function of currently deferred (planned) task */\n    get fn() {\n        return this._fn;\n    }\n    /**\n     * Cancel deferred task and planning passed\n     * @param task - task function\n     * @param delay - time to delay task execution\n     *  - pass negative or false to execute task immediately\n     *  - pass 0 to plan task to the macrotask\n     *  - pass positive number x to delay task on x ms.\n     * */\n    put(task, delay = false) {\n        const prev = this.cancel();\n        if (typeof task === 'function') {\n            if (delay && typeof delay === 'string')\n                delay = +delay;\n            if (typeof delay === 'number' && delay >= 0) {\n                this._fn = task;\n                this._timeout = window.setTimeout(this.run, delay);\n            }\n            else {\n                task();\n            }\n        }\n        return prev;\n    }\n    /** Cancel deferred (planned) task */\n    cancel() {\n        const prev = this._fn;\n        (typeof this._timeout === 'number') && clearTimeout(this._timeout);\n        this._fn = this._timeout = null;\n        return prev;\n    }\n}\n","/**\n * @returns Promise that will be resolved in `timeout` with optional `payload`\n */\nexport function promisifyTimeout(timeout, payload) {\n    return new Promise((resolve) => setTimeout(resolve.bind(null, payload), timeout));\n}\n/**\n * @returns Promise that will be resolved by dispatching `event` on `target`\n * Or it will be rejected in `timeout` if it's specified\n * Optional `options` for addEventListener can be also specified\n */\nexport function promisifyEvent(target, event, timeout, options) {\n    return new Promise((resolve, reject) => {\n        function eventCallback(e) {\n            target.removeEventListener(event, eventCallback, options);\n            resolve(e);\n        }\n        target.addEventListener(event, eventCallback, options);\n        if (typeof timeout === 'number' && timeout >= 0) {\n            setTimeout(() => reject(new Error('Rejected by timeout')), timeout);\n        }\n    });\n}\n/**\n * Short helper to make Promise from element state marker\n * @returns Promise that will be resolved if the target `marker` property is truthful or `event` is dispatched\n * @example\n * `const imgReady = promisifyMarker(eslImage, 'ready');`\n */\nexport function promisifyMarker(target, marker, event = marker) {\n    if (target[marker])\n        return Promise.resolve(target);\n    return promisifyEvent(target, event).then(() => target);\n}\n/**\n * Call `callback` limited by `tryCount` amount of times with interval in `timeout` ms\n * @returns Promise that will be resolved as soon as callback returns truthy value, or reject it by limit.\n */\nexport function tryUntil(callback, tryCount = 2, timeout = 100) {\n    return new Promise((resolve, reject) => {\n        (function check() {\n            let result;\n            try {\n                result = callback();\n            }\n            catch (_a) {\n                result = undefined;\n            }\n            if (result || (tryCount--) < 0) {\n                result ? resolve(result) : reject(new Error('Rejected by limit of tries'));\n            }\n            else {\n                setTimeout(check, timeout);\n            }\n        })();\n    });\n}\n/**\n * Call async callback in a sequence passed number of times\n * Initial call starts as a microtask\n * @param callback - async chain function\n * @param count - count o calls\n * @returns sequence end promise\n */\nexport function repeatSequence(callback, count = 1) {\n    if (count < 1)\n        return Promise.reject();\n    if (count === 1)\n        return Promise.resolve().then(callback);\n    return repeatSequence(callback, count - 1).then(callback);\n}\n/**\n * Create Deferred Object that wraps promise and its resolve and reject callbacks\n */\nexport function createDeferred() {\n    let reject;\n    let resolve;\n    // Both reject and resolve will be assigned anyway while the Promise constructing.\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n/**\n * Safe wrap for Promise.resolve to use in Promise chain\n * @example\n * `const resolvedPromise = rejectedPromise.catch(resolvePromise);`\n */\nexport function resolvePromise(arg) {\n    return Promise.resolve(arg);\n}\n/**\n * Safe wrap for Promise.reject to use in Promise chain\n * @example\n * `const rejectedPromise = resolvedPromise.then(rejectPromise);`\n */\nexport function rejectPromise(arg) {\n    return Promise.reject(arg);\n}\n/**\n * Promise utils helper class\n * Note: use individual methods in case you need correct \"tree shaking\"\n */\nexport class PromiseUtils {\n}\nPromiseUtils.fromTimeout = promisifyTimeout;\nPromiseUtils.fromEvent = promisifyEvent;\nPromiseUtils.fromMarker = promisifyMarker;\nPromiseUtils.repeat = repeatSequence;\nPromiseUtils.tryUntil = tryUntil;\nPromiseUtils.deferred = createDeferred;\nPromiseUtils.resolve = resolvePromise;\nPromiseUtils.reject = rejectPromise;\n","/**\n * Postpone action after next render\n */\nexport const afterNextRender = (callback) => requestAnimationFrame(() => requestAnimationFrame(callback));\n/**\n * Decorate function to schedule execution after next render\n * @returns decorated function\n */\nexport const rafDecorator = (fn) => {\n    let lastArgs = null; // null if no calls requested\n    return function (...args) {\n        if (lastArgs === null) {\n            requestAnimationFrame(() => {\n                lastArgs && fn.call(this, ...lastArgs);\n                lastArgs = null;\n            });\n        }\n        lastArgs = args;\n    };\n};\n","const BINDINGS_STORE_KEY = '__fnBindings__';\n/** Decorator \"bind\" allows to bind prototype method context to class instance */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function bind(target, propertyKey, descriptor) {\n    // Validation check\n    if (!descriptor || (typeof descriptor.value !== 'function')) {\n        throw new TypeError('Only class methods can be decorated via @bind');\n    }\n    // Original function\n    const fn = descriptor.value;\n    return {\n        enumerable: descriptor.enumerable,\n        configurable: descriptor.configurable,\n        get() {\n            // Accessing via prototype returns original function\n            // If the constructor property is in the context then it's not an instance\n            if (!this || this === target || Object.hasOwnProperty.call(this, 'constructor')) {\n                return fn;\n            }\n            // Bounded functions store\n            let bindings = this[BINDINGS_STORE_KEY];\n            if (!bindings) {\n                bindings = this[BINDINGS_STORE_KEY] = new WeakMap();\n            }\n            // Store binding if it does not exist\n            if (!bindings.has(fn)) {\n                bindings.set(fn, fn.bind(this));\n            }\n            // Return binding\n            return bindings.get(fn);\n        },\n        set(value) {\n            Object.defineProperty(this, propertyKey, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value\n            });\n        }\n    };\n}\n","import { defaultArgsHashFn, memoizeFn } from '../misc/memoize';\nimport { isPrototype, getPropertyDescriptor } from '../misc/object';\n/**\n * Memoization decorator helper.\n * @see memoizeFn Original memoizeFn function decorator.\n */\nexport function memoize(hashFn = defaultArgsHashFn) {\n    return function (target, prop, descriptor) {\n        if (!descriptor || typeof (descriptor.value || descriptor.get) !== 'function') {\n            throw new TypeError('Only get accessors or class methods can be decorated via @memoize');\n        }\n        if (isPrototype(target)) {\n            // Object members\n            (typeof descriptor.get === 'function') && (descriptor.get = memoizeGetter(descriptor.get, prop));\n            (typeof descriptor.value === 'function') && (descriptor.value = memoizeMethod(descriptor.value, prop, hashFn));\n        }\n        else {\n            // Static members\n            (typeof descriptor.get === 'function') && (descriptor.get = memoizeFn(descriptor.get));\n            (typeof descriptor.value === 'function') && (descriptor.value = memoizeFn(descriptor.value, hashFn));\n        }\n    };\n}\n// Lock storage to prevent cache logic for some key\nconst locks = new WeakMap();\nconst defineOwnKeySafe = (obj, prop, value) => {\n    locks.set(obj, prop); // IE try to get key with the prototype instance call, so we lock it\n    Object.defineProperty(obj, prop, { value, writable: true, configurable: true });\n    locks.delete(obj); // Free property key\n};\n/** Cache getter result as an object own property */\nfunction memoizeGetter(originalMethod, prop) {\n    return function () {\n        if (locks.get(this) === prop)\n            return originalMethod;\n        const value = originalMethod.call(this);\n        defineOwnKeySafe(this, prop, value);\n        return value;\n    };\n}\n/** Cache method memo function in the current context on call */\nfunction memoizeMethod(originalMethod, prop, hashFn) {\n    return function (...args) {\n        if (locks.get(this) === prop)\n            return originalMethod;\n        const memo = memoizeFn(originalMethod, hashFn);\n        defineOwnKeySafe(this, prop, memo);\n        return memo.apply(this, args);\n    };\n}\n/**\n * Clear memoization cache for passed target and property.\n * Accepts not own properties.\n * Note: be sure that you targeting memoized property or function.\n * Clear utility has no 100% check to prevent modifying incorrect (not memoized) property keys\n */\nmemoize.clear = function (target, property) {\n    const desc = getPropertyDescriptor(target, property);\n    if (!desc)\n        return;\n    if (typeof desc.get === 'function' && typeof desc.get.clear === 'function')\n        return desc.get.clear();\n    if (typeof desc.value === 'function' && typeof desc.value.clear === 'function')\n        return desc.value.clear();\n    if (Object.hasOwnProperty.call(target, property))\n        delete target[property];\n};\n/** Check if property has cache for the passed params */\nmemoize.has = function (target, property, ...params) {\n    const desc = getPropertyDescriptor(target, property);\n    if (!desc)\n        return false;\n    if (typeof desc.get === 'function' && typeof desc.get.has === 'function')\n        return desc.get.has(...params);\n    if (typeof desc.value === 'function' && typeof desc.value.has === 'function')\n        return desc.value.has(...params);\n    return Object.hasOwnProperty.call(target, property);\n};\n","/**\n * `@prop` is auxiliary decorator to define a field on the prototype level.\n *` @prop` can be used to override decorated property from the parent level\n *\n * You can also use an @override decorator in combination with ECMA Script class property definition:\n * `@prop() public field: any = initial value;`\n *\n * The class property initial value is a part of object creation, so it goes to the object itself,\n * while the @override value is defined on the prototype level.\n *\n * @param prototypeConfig - prototype property configuration\n */\nexport function prop(prototypeConfig = {}) {\n    return function (obj, name) {\n        if (Object.hasOwnProperty.call(obj, name)) {\n            throw new TypeError('Can\\'t override own property');\n        }\n        Object.defineProperty(obj, name, {\n            value: prototypeConfig.value,\n            writable: !prototypeConfig.readonly,\n            enumerable: true,\n            configurable: true\n        });\n    };\n}\n","import { onDocumentReady } from '../dom/ready';\n/** Defer method execution to the next task with dom ready state precondition */\nexport function ready(target, propertyKey, descriptor) {\n    if (!descriptor || typeof descriptor.value !== 'function') {\n        throw new TypeError('Only class methods can be decorated via document ready decorator');\n    }\n    const fn = descriptor.value;\n    descriptor.value = function (...arg) {\n        onDocumentReady(() => fn.call(this, ...arg));\n    };\n}\n","/**\n * Get the Element that is the root element of the document.\n * @param element - element for which to get the document element\n * */\nexport const getDocument = (element = window) => {\n    return (element instanceof Window ? element.document : element.ownerDocument).documentElement;\n};\n/**\n * Get the name of node.\n * @param element - element for which to get the name\n */\nexport const getNodeName = (element) => {\n    return element && !(element instanceof Window) ? (element.nodeName).toLowerCase() : '';\n};\n/**\n * Get the parent of the specified element in the DOM tree.\n * @param element - element for which to get the parent\n */\nexport const getParentNode = (element) => {\n    if (getNodeName(element) === 'html')\n        return element;\n    return (window.ShadowRoot\n        ? element instanceof ShadowRoot\n            ? element.host\n            : element.assignedSlot || element.parentNode\n        : element.parentNode) || getDocument(element);\n};\n","import { wrap } from '../misc/array';\n/** Store locks for key element classes*/\nconst lockStore = new WeakMap();\n/** Mange className lock for the element */\nconst lock = (el, className, locker) => {\n    const elLocks = lockStore.get(el) || new Map();\n    const classLocks = elLocks.get(className) || new Set();\n    classLocks.add(locker);\n    elLocks.set(className, classLocks);\n    lockStore.set(el, elLocks);\n};\n/**\n * Manage className unlock for the element\n * @returns true if className have no locks\n */\nconst unlock = (el, className, locker) => {\n    const elLocks = lockStore.get(el);\n    if (!elLocks)\n        return true;\n    const classLocks = elLocks.get(className);\n    if (!classLocks)\n        return true;\n    classLocks.delete(locker);\n    return !classLocks.size;\n};\n/**\n * Add single class to the element.\n * Supports inversion and locker management.\n */\nconst add = (el, className, locker) => {\n    if (className[0] === '!')\n        return CSSClassUtils.remove(el, className.substring(1), locker);\n    if (locker)\n        lock(el, className, locker);\n    el.classList.add(className);\n};\n/**\n * Remove single class from the element.\n * Supports inversion and locker management.\n */\nconst remove = (el, className, locker) => {\n    if (className[0] === '!')\n        return CSSClassUtils.add(el, className.substring(1), locker);\n    if (locker && !unlock(el, className, locker))\n        return;\n    if (!locker)\n        CSSClassUtils.unlock(el, className);\n    el.classList.remove(className);\n};\n/**\n * CSS class manipulation utilities.\n *\n * Allows to manipulate with CSS classes with the following set of sub-features:\n * - JQuery-like enumeration - you can pass multiple tokens separated by space\n * - safe checks - empty or falsy token sting will be ignored without throwing an error\n * - inversion syntax - tokens that start from '!' will be processed with inverted action\n * (e.g. addCls(el, '!class') - will remove 'class' from the element, while removeCls(el, '!class') adds 'class' to the element)\n * - class locks - you can manipulate with classes using `locker` option that takes into account the modification initiator.\n * That means the class added in 'locker' mode will not be removed until all initiators that requested add class have requested its removal.\n * */\nexport class CSSClassUtils {\n    /** Splitting passed token string into CSS class names array. */\n    static splitTokens(tokenString) {\n        return (tokenString || '').split(' ').filter((str) => !!str);\n    }\n    /**\n     * Add all classes from the class token string to the element.\n     * @see CSSClassUtils\n     * */\n    static add(els, cls, locker) {\n        const tokens = CSSClassUtils.splitTokens(cls);\n        wrap(els).forEach((el) => tokens.forEach((className) => add(el, className, locker)));\n    }\n    /**\n     * Remove all classes from the class token string to the element.\n     * @see CSSClassUtils\n     * */\n    static remove(els, cls, locker) {\n        const tokens = CSSClassUtils.splitTokens(cls);\n        wrap(els).forEach((el) => tokens.forEach((className) => remove(el, className, locker)));\n    }\n    /**\n     * Toggle all classes from the class token string on the element to the passed state.\n     * @see CSSClassUtils\n     * */\n    static toggle(els, cls, state, locker) {\n        (state ? CSSClassUtils.add : CSSClassUtils.remove)(els, cls, locker);\n    }\n    /** Remove all lockers for the element or passed element className */\n    static unlock(els, className) {\n        if (className) {\n            wrap(els).forEach((el) => { var _a; return (_a = lockStore.get(el)) === null || _a === void 0 ? void 0 : _a.delete(className); });\n        }\n        else {\n            wrap(els).forEach((el) => lockStore.delete(el));\n        }\n    }\n}\n","export class EventUtils {\n    /**\n     * Dispatch custom event.\n     * Event bubbles and is cancelable by default, use `eventInit` to override that.\n     * @param el - element target\n     * @param eventName - event name\n     * @param eventInit - custom event init. See {@link CustomEventInit}\n     */\n    static dispatch(el, eventName, eventInit) {\n        const init = Object.assign({\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }, eventInit || {});\n        return el.dispatchEvent(new CustomEvent(eventName, init));\n    }\n    /** Get original CustomEvent source */\n    static source(e) {\n        const targets = (e.composedPath && e.composedPath());\n        return targets ? targets[0] : e.target;\n    }\n    /** Check if the passed event is {@link MouseEvent} */\n    static isMouseEvent(event) {\n        return window.MouseEvent && event instanceof MouseEvent;\n    }\n    /** Check if the passed event is {@link TouchEvent} */\n    static isTouchEvent(event) {\n        return window.TouchEvent && event instanceof TouchEvent;\n    }\n    /** Normalize TouchEvent or PointerEvent */\n    static normalizeTouchPoint(event) {\n        const source = EventUtils.isTouchEvent(event) ? event.changedTouches[0] : event;\n        return {\n            x: source.pageX,\n            y: source.pageY\n        };\n    }\n    /** Normalize MouseEvent */\n    static normalizeCoordinates(event, elem) {\n        const source = EventUtils.isTouchEvent(event) ? event.changedTouches[0] : event;\n        const props = elem.getBoundingClientRect();\n        const top = props.top + window.scrollY;\n        const left = props.left + window.scrollX;\n        return {\n            x: source.pageX - left,\n            y: source.pageY - top\n        };\n    }\n    /** Stub method to prevent event from bubbling out of target */\n    static stopPropagation(e) {\n        e === null || e === void 0 ? void 0 : e.stopPropagation();\n    }\n    /** Stub method to prevent default event behaviour */\n    static preventDefault(e) {\n        e === null || e === void 0 ? void 0 : e.preventDefault();\n    }\n}\n","export const TAB = 'Tab';\nexport const ENTER = 'Enter';\nexport const ESC = 'Escape';\nexport const SPACE = ' ';\nexport const BACKSPACE = 'Backspace';\nexport const ALT = 'Alt';\nexport const SHIFT = 'Shift';\nexport const CONTROL = 'Control';\nexport const PAUSE = 'Pause';\nexport const END = 'End';\nexport const HOME = 'Home';\nexport const DELETE = 'Delete';\nexport const PAGE_UP = 'PageUp';\nexport const PAGE_DOWN = 'PageDown';\nexport const ARROW_LEFT = 'ArrowLeft';\nexport const ARROW_UP = 'ArrowUp';\nexport const ARROW_RIGHT = 'ArrowRight';\nexport const ARROW_DOWN = 'ArrowDown';\nexport const SYSTEM_KEYS = [TAB, ALT, SHIFT, CONTROL, PAGE_UP, PAGE_DOWN, ARROW_LEFT, ARROW_UP, ARROW_RIGHT, ARROW_DOWN];\n","/**\n * Execute callback in bounds of the next task with dom ready state precondition\n */\nexport function onDocumentReady(callback) {\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', function fn() {\n            document.removeEventListener('DOMContentLoaded', fn);\n            setTimeout(() => callback());\n        });\n    }\n    else {\n        setTimeout(() => callback());\n    }\n}\n","/**\n * A Rect describes the size and position of a rectangle.\n */\nexport class Rect {\n    constructor(x, y, width, height) {\n        /** The X coordinate of the Rect's origin (top-left corner of the rectangle). */\n        this.x = 0;\n        /** The Y coordinate of the Rect's origin (top-left corner of the rectangle). */\n        this.y = 0;\n        /** The width of the Rect. */\n        this.width = 0;\n        /** The height of the Rect. */\n        this.height = 0;\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = width || 0;\n        this.height = height || 0;\n    }\n    /**\n     * The static method creates a new Rect instance from a rect-like object.\n     * @param rect - rect-like object\n     */\n    static from(rect = {}) {\n        return new this(rect.x || rect.left, rect.y || rect.top, rect.width, rect.height);\n    }\n    /**\n     * The static method checks the equality of the two Rect instances.\n     * @param rect1 - first instance of Rect\n     * @param rect2 - second instance of Rect\n     */\n    static isEqual(rect1, rect2) {\n        return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;\n    }\n    /**\n     * Get the top coordinate value of the Rect (has the same value as y).\n     */\n    get top() {\n        return this.y;\n    }\n    /**\n     * Get the left coordinate value of the Rect (has the same value as x).\n     */\n    get left() {\n        return this.x;\n    }\n    /**\n     * Get the right coordinate value of the DOMRect.\n     */\n    get right() {\n        return this.x + this.width;\n    }\n    /**\n     * Get the bottom coordinate value of the Rect.\n     */\n    get bottom() {\n        return this.y + this.height;\n    }\n    /**\n     * Get the center X coordinate value of the Rect.\n     */\n    get cx() {\n        return this.x + this.width / 2;\n    }\n    /**\n     * Get the center Y coordinate value of the Rect.\n     */\n    get cy() {\n        return this.y + this.height / 2;\n    }\n    /**\n     * Grow the Rect by the specified increment in pixels.\n     * It increases the size of the Rect by moving each point on the edge of the Rect to a certain distance further away from the center of the Rect.\n     * @param increment - distance to grow in pixels\n     */\n    grow(increment) {\n        this.y -= increment;\n        this.x -= increment;\n        this.height += 2 * increment;\n        this.width += 2 * increment;\n        return this;\n    }\n    /**\n     * Shrink the Rect by the specified decrement in pixels.\n     * It reduces the size of the Rect by moving each point on the edge of the Rect to a certain distance closer to the center of the Rect.\n     * @param decrement - distance to shrink in pixels\n     */\n    shrink(decrement) {\n        return this.grow(-decrement);\n    }\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { memoize } from '../decorators/memoize';\n// TODO: functional\nexport class RTLUtils {\n    /** Check if the element in a RTL direction context */\n    static isRtl(el = document.body) {\n        return getComputedStyle(el).direction === 'rtl';\n    }\n    /**\n     * @returns RTL scroll type (lazy, memoized)\n     */\n    static get scrollType() {\n        let scrollType = 'default';\n        const el = createDummyEl();\n        document.body.appendChild(el);\n        if (el.scrollLeft <= 0) {\n            el.scrollLeft = 2;\n            scrollType = el.scrollLeft < 2 ? 'negative' : 'reverse';\n        }\n        document.body.removeChild(el);\n        return scrollType;\n    }\n    static normalizeScrollLeft(el, value = null, isRtl = RTLUtils.isRtl(el)) {\n        value = (value === null) ? el.scrollLeft : value;\n        switch (isRtl ? RTLUtils.scrollType : '') {\n            case 'negative':\n                return el.scrollWidth - el.clientWidth + value;\n            case 'reverse':\n                return el.scrollWidth - el.clientWidth - value;\n            default:\n                return value;\n        }\n    }\n}\n__decorate([\n    memoize()\n], RTLUtils, \"scrollType\", null);\n/** Creates the dummy test element with a horizontal scroll presented */\nfunction createDummyEl() {\n    const el = document.createElement('div');\n    el.appendChild(document.createTextNode('ESL!'));\n    el.dir = 'rtl';\n    Object.assign(el.style, {\n        position: 'absolute',\n        top: '-1000px',\n        width: '4px',\n        height: '1px',\n        fontSize: '14px',\n        overflow: 'scroll'\n    });\n    return el;\n}\n","import { tryUntil } from '../async/promise';\nimport { getNodeName, getParentNode } from './api';\nconst $html = document.documentElement;\nconst initiatorSet = new Set();\n// TODO: functional\nexport class ScrollUtils {\n    /** Check vertical scroll based on content height */\n    static hasVerticalScroll(target = $html) {\n        return target.scrollHeight > target.clientHeight;\n    }\n    /**\n     * Disable scroll on the page.\n     * @param strategy - to make scroll visually disabled\n     * */\n    static lock(strategy) {\n        const hasScroll = ScrollUtils.hasVerticalScroll();\n        if (strategy && strategy !== 'none' && hasScroll) {\n            $html.classList.add(`esl-${strategy}-scroll`);\n        }\n        $html.classList.add('esl-disable-scroll');\n    }\n    /**\n     * Enable scroll on the page.\n     * */\n    static unlock() {\n        $html.classList.remove('esl-disable-scroll', 'esl-pseudo-scroll', 'esl-native-scroll');\n    }\n    /**\n     * Disable scroll on the page.\n     * @param initiator - object to associate request with\n     * @param strategy - to make scroll visually disabled\n     *\n     * TODO: currently requests with different strategy is not taken into account\n     * */\n    static requestLock(initiator, strategy) {\n        initiator && initiatorSet.add(initiator);\n        (initiatorSet.size > 0) && ScrollUtils.lock(strategy);\n    }\n    /**\n     * Enable scroll on the page in case it was requested with given initiator.\n     * @param initiator - object to associate request with\n     * @param strategy - to make scroll visually disabled\n     */\n    static requestUnlock(initiator, strategy) {\n        initiator && initiatorSet.delete(initiator);\n        (initiatorSet.size === 0) && ScrollUtils.unlock();\n    }\n}\n/**\n * Get the list of all scroll parents, up the list of ancestors until we get to the top window object.\n * @param element - element for which you want to get the list of all scroll parents\n * @param list - array of elements to concatenate with the list of all scroll parents of element (optional)\n */\nexport function getListScrollParents(element, list = []) {\n    var _a;\n    const scrollParent = getScrollParent(element);\n    const isBody = scrollParent === ((_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body);\n    const target = isBody\n        ? isScrollParent(scrollParent) ? scrollParent : []\n        : scrollParent;\n    const updatedList = list.concat(target);\n    return isBody\n        ? updatedList\n        : updatedList.concat(getListScrollParents(getParentNode(scrollParent)));\n}\n/**\n * Get the scroll parent of the specified element in the DOM tree.\n * @param node - element for which to get the scroll parent\n */\nexport function getScrollParent(node) {\n    var _a;\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n        return (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;\n    }\n    if (node instanceof HTMLElement && isScrollParent(node)) {\n        return node;\n    }\n    return getScrollParent(getParentNode(node));\n}\n/**\n * Check that element is scroll parent.\n * @param element - element for checking\n * */\nexport function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n/**\n * This is a promise-based version of scrollIntoView().\n * Method scrolls the element's parent container such that the element on which\n * scrollIntoView() is called is visible to the user. The promise is resolved when\n * the element became visible to the user and scrolling stops.\n *\n * Note: Please, use the native element.scrollIntoView() if you don't need a promise\n * to detect the moment when the scroll is finished or you don't use smooth behavior.\n * @param element - element to be made visible to the user\n * @param options - scrollIntoView options\n */\nexport function scrollIntoView(element, options) {\n    let same = 0;\n    let lastLeft;\n    let lastTop;\n    const check = () => {\n        const { top, left } = element.getBoundingClientRect();\n        if (top !== lastTop || left !== lastLeft) {\n            same = 0;\n            lastTop = top;\n            lastLeft = left;\n        }\n        return same++ > 2;\n    };\n    element.scrollIntoView(options);\n    return tryUntil(check, 333, 30); // will check top position every 30ms, but not more than 250 times (10s)\n}\n","/** Check that `nodeA` and `nodeB` are from the same tree path */\nexport const isRelativeNode = (nodeA, nodeB) => {\n    return !!(nodeA && nodeB) && (nodeA.contains(nodeB) || nodeB.contains(nodeA));\n};\n/** Create function that finds next dom element, that matches selector, in the sequence declared by `next` function */\nexport const createSequenceFinder = (next) => {\n    return function (base, sel) {\n        for (let target = next(base); target; target = next(target)) {\n            if (!sel || target.matches(sel))\n                return target;\n        }\n        return null;\n    };\n};\n/** @returns first matching next sibling or null*/\nexport const findNext = createSequenceFinder((el) => el.nextElementSibling);\n/** @returns first matching previous sibling or null*/\nexport const findPrev = createSequenceFinder((el) => el.previousElementSibling);\n/** @returns first matching parent or null*/\nexport const findParent = createSequenceFinder((el) => el.parentElement);\n/** @returns Array of all matching elements in subtree or empty array */\nexport const findAll = (base, sel) => {\n    return sel ? Array.from(base.querySelectorAll(sel)) : [base];\n};\n/** @returns Array of all matching children or empty array */\nexport const findChildren = (base, sel) => {\n    return Array.from(base.children).filter((el) => !sel || el.matches(sel));\n};\n/**\n * Find closest parent node of `node` by `predicate`.\n * Optional `skipSelf` to skip initial node\n */\nexport const findClosestBy = (node, predicate, skipSelf = false) => {\n    let current = skipSelf && node ? node.parentNode : node;\n    while (current) {\n        if (predicate(current))\n            return current;\n        current = current.parentNode;\n    }\n    return null;\n};\n/** @deprecated Cumulative traversing utility set */\nexport class TraversingUtils {\n}\nTraversingUtils.isRelative = isRelativeNode;\nTraversingUtils.closestBy = findClosestBy;\nTraversingUtils.createSequenceFinder = createSequenceFinder;\nTraversingUtils.findNext = findNext;\nTraversingUtils.findPrev = findPrev;\nTraversingUtils.findParent = findParent;\nTraversingUtils.findAll = findAll;\nTraversingUtils.findChildren = findChildren;\n","import { Rect } from './rect';\n/**\n * Get the window object associated with a document of the specified element.\n * @param node - element for which to get window\n * */\nexport function getWindow(node) {\n    if (node === null)\n        return window;\n    if (node instanceof Window)\n        return node;\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n}\n/**\n * Get the size and position of the window.\n * @returns\n */\nexport function getWindowRect(wnd = window) {\n    return Rect.from({\n        x: wnd.scrollX,\n        y: wnd.scrollY,\n        width: wnd.innerWidth || wnd.document.documentElement.clientWidth,\n        height: wnd.innerHeight || wnd.document.documentElement.clientHeight\n    });\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ExportNs } from './export-ns';\nconst { userAgent, vendor, platform } = window.navigator;\n// IE Detection\nexport const isTrident = /trident/i.test(userAgent);\nexport const isIE = isTrident;\n// Edge Detection\nexport const isEdgeHTML = /edg([ea]|ios)/i.test(userAgent);\nexport const isBlinkEdge = /\\sedg\\//i.test(userAgent);\nexport const isEdge = isEdgeHTML || isBlinkEdge;\n// Gecko\nexport const isGecko = /gecko/i.test(userAgent) && !/like gecko/i.test(userAgent);\nexport const isFirefox = /firefox|iceweasel|fxios/i.test(userAgent);\n// Opera / Chrome\nexport const isOpera = /(?:^opera.+?version|opr)/.test(userAgent);\nexport const isChrome = !isOpera && /google inc/.test(vendor);\n// Webkit\nexport const isWebkit = /(apple)?webkit/i.test(userAgent);\n// Safari\nexport const isSafari = isWebkit && /^((?!chrome|android).)*safari/i.test(userAgent);\n// Blink\nexport const isBlink = isWebkit && !isSafari;\n// Bot detection\nexport const isBot = /Chrome-Lighthouse|Google Page Speed Insights/i.test(userAgent);\n// Mobile\nexport const isAndroid = /Android/i.test(userAgent);\nexport const isMobileIOS13 = /* iOS 13+ detection */ (platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);\nexport const isMobileIOS = /iPad|iPhone|iPod/.test(platform) || isMobileIOS13;\nexport const isLegacyMobile = /webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\nexport const isMobile = isMobileIOS || isAndroid || isLegacyMobile;\nexport const isMobileSafari = isMobileIOS && isWebkit && /CriOS/i.test(userAgent);\n// Touch Detection\nexport const isTouchDevice = (() => {\n    const navApi = window.navigator;\n    if (navApi.maxTouchPoints || navApi.msMaxTouchPoints)\n        return true;\n    return ('ontouchstart' in window) || ('DocumentTouch' in window && document instanceof Touch);\n})();\n// Hover check\n// Note: always true for IE\nexport const hasHover = !matchMedia('(hover: none)').matches;\n/** @deprecated TODO: needs to be reworked or moved away from device detector */\nexport const TOUCH_EVENTS = (() => {\n    const isTouch = isTouchDevice;\n    return {\n        START: isTouch ? 'touchstart' : 'pointerdown',\n        MOVE: isTouch ? 'touchmove' : 'pointermove',\n        END: isTouch ? 'touchend' : 'pointerup'\n    };\n})();\n/**\n * Device detection utility\n * @readonly\n */\nlet DeviceDetector = class DeviceDetector {\n};\n// IE Detection\nDeviceDetector.isTrident = isTrident;\nDeviceDetector.isIE = isIE;\n// Edge Detection\nDeviceDetector.isEdgeHTML = isEdgeHTML;\nDeviceDetector.isBlinkEdge = isBlinkEdge;\nDeviceDetector.isEdge = isEdge;\n// Gecko\nDeviceDetector.isGecko = isGecko;\nDeviceDetector.isFirefox = isFirefox;\n// Opera / Chrome\nDeviceDetector.isOpera = isOpera;\nDeviceDetector.isChrome = isChrome;\n// Webkit\nDeviceDetector.isWebkit = isWebkit;\n// Safari\nDeviceDetector.isSafari = isSafari;\n// Blink\nDeviceDetector.isBlink = isBlink;\n// Bot detection\nDeviceDetector.isBot = isBot;\n// Mobile\nDeviceDetector.isAndroid = isAndroid;\nDeviceDetector.isMobileIOS13 = isMobileIOS13;\nDeviceDetector.isMobileIOS = isMobileIOS;\nDeviceDetector.isLegacyMobile = isLegacyMobile;\nDeviceDetector.isMobile = isMobile;\nDeviceDetector.isMobileSafari = isMobileSafari;\n// Touch Detection\nDeviceDetector.isTouchDevice = isTouchDevice;\n// Hover check\n// Note: always true for IE\nDeviceDetector.hasHover = hasHover;\n/** @deprecated TODO: needs to be reworked or moved away from device detector */\nDeviceDetector.TOUCH_EVENTS = TOUCH_EVENTS;\nDeviceDetector = __decorate([\n    ExportNs('DeviceDetector')\n], DeviceDetector);\nexport { DeviceDetector };\n","const NS_NAME = 'ESL';\n/**\n * Nested declaration helper\n */\nfunction define(root, name, value) {\n    name.split('.').reduce((obj, key, index, parts) => {\n        if (parts.length === index + 1) {\n            return (obj[key] = obj[key] || value);\n        }\n        const type = typeof obj[key];\n        if (type !== 'undefined' && type !== 'object' && type !== 'function') {\n            throw new Error(`Can not define ${value} on ${name}`);\n        }\n        return (obj[key] = obj[key] || {});\n    }, root);\n}\n/**\n * Method to manually declare key in library namespace\n * See {@link ExportNs} decorator for details\n */\nexport const exportNs = (name, module) => {\n    if (!(NS_NAME in window))\n        return;\n    define(window[NS_NAME], name, module);\n};\n/**\n * Decorator to declare function or class in a global ns\n * @param name - key path to declare in ESL global ns\n * NOTE: path parts should be separated by dots\n * @example\n * ```ts\n * @Export('Package.Component')\n * ```\n * NOTE: in case declaration contains components-packages, their origins will be mixed with declaration in a Runtime\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function ExportNs(name) {\n    return (module) => exportNs(name || module.name, module);\n}\n/** Declare ESL global */\nExportNs.declare = () => {\n    if ('ESL' in window)\n        return;\n    Object.defineProperty(window, 'ESL', { value: {} });\n};\n","/** Fix IE browser to allow to display alert under iframe */\nexport function createZIndexIframe() {\n    const iframe = document.createElement('iframe');\n    iframe.className = 'ie-zindex-fix';\n    iframe.src = 'about:blank';\n    return iframe;\n}\n","import { identity } from './functions';\nimport { isArrayLike } from './object';\n/** Split array into tuples */\nexport const tuple = (arr) => arr.reduce((acc, el) => {\n    if (acc.length === 0 || acc[acc.length - 1].length >= 2)\n        acc.push([]);\n    acc[acc.length - 1].push(el);\n    return acc;\n}, []);\n/** Flat array - unwraps one level of nested arrays */\nexport const flat = (arr) => arr.reduce((acc, el) => el ? acc.concat(el) : acc, []);\n/** Wraps passed object or primitive to array */\nexport const wrap = (arr) => {\n    if (arr === undefined || arr === null)\n        return [];\n    if (Array.isArray(arr))\n        return arr;\n    return [arr];\n};\nexport function unwrap(value) {\n    return isArrayLike(value) ? value[0] : value;\n}\n/** Makes array values unique */\nexport const uniq = (arr) => {\n    const result = [];\n    const set = new Set();\n    arr.forEach((item) => set.add(item));\n    set.forEach((item) => result.push(item));\n    return result;\n};\nexport function range(n, filler = identity) {\n    const arr = Array(n);\n    let i = 0;\n    while (i < n)\n        arr[i] = filler(i++);\n    return arr;\n}\n/**\n * @returns object with a criteria value as a key and an array of original items that belongs to the current criteria value\n */\nexport const groupBy = (array, group) => {\n    return array.reduce((obj, el) => {\n        const key = group(el);\n        obj[key] ? obj[key].push(el) : obj[key] = [el];\n        return obj;\n    }, {});\n};\n","import { get } from './object';\n/** Converts string to kebab-case notation */\nexport const toKebabCase = (str) => {\n    return str.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[\\s_]+/g, '-').toLowerCase();\n};\n/** Converts string to camelCase notation */\nexport const toCamelCase = (str) => {\n    return str.trim().replace(/[\\s-,_]+([a-zA-Z0-9]?)/g, (match, word) => word.toUpperCase());\n};\n/** Makes the first non-indent (space, tab, newline) letter in the string capitalized */\nexport const capitalize = (str) => {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t' || str[i] === '\\n'))\n        i++;\n    return str.slice(0, i) + str.charAt(i).toUpperCase() + str.slice(i + 1);\n};\n/** Unwraps string from parenthesis */\nexport const unwrapParenthesis = (str) => {\n    return str.trim().replace(/^\\((.*)\\)$/, '$1').trim();\n};\n/**\n * Parses number with the ability to pass an alternative fallback for NaN.\n * Note: falsy values except 0 are treated as NaN\n */\nexport const parseNumber = (str, nanValue) => {\n    if (str === 0)\n        return 0;\n    const value = +(str || NaN);\n    return isNaN(value) ? nanValue : value;\n};\n/**\n * Common function that returns coefficient aspect ratio\n * Supported formats: w:h, w/h, coefficient\n * @example\n * `16:9`, `16/9`, `1.77`\n * @param str - string to parse\n * @returns aspect ratio coefficient\n */\nexport function parseAspectRatio(str) {\n    const [w, h] = str.split(/[:/]/);\n    if (typeof h !== 'undefined')\n        return +w / +h;\n    return +w || 0;\n}\n/** Evaluates passed string or returns `defaultValue` */\nexport function evaluate(str, defaultValue) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-implied-eval\n        return str ? (new Function(`return ${str}`))() : defaultValue;\n    }\n    catch (e) {\n        console.warn('Cannot parse value ', str, e);\n        return defaultValue;\n    }\n}\n/** Default RegExp to match replacements in the string for the {@link format} function */\nexport const DEF_FORMAT_MATCHER = /{[{%]?([\\w.]+)[%}]?}/g;\n/** Replaces `{key}` patterns in the string from the source object */\nexport function format(str, source, matcher = DEF_FORMAT_MATCHER) {\n    return str.replace(matcher, (match, key) => {\n        const val = get(source, key);\n        return val === undefined ? match : val;\n    });\n}\n","/** Function that does nothing */\nexport const noop = () => undefined;\n/** Function that returns the first argument */\nexport const identity = (arg) => arg;\n","/**\n * Memoization decorator function. Caches the original function result according to hash generated from arguments.\n * In case the hash function returns `undefined` value will not be memoized.\n * @see MemoHashFn Hash function signature.\n */\nexport function memoizeFn(fn, hashFn = defaultArgsHashFn) {\n    function memo(...args) {\n        const key = hashFn(...args);\n        if (key !== null && typeof key !== 'string') {\n            console.warn(`Can't cache value for ${fn.name} call.`);\n            return fn.apply(this, args);\n        }\n        if (!memo.cache.has(key)) {\n            memo.cache.set(key, fn.apply(this, args));\n        }\n        return memo.cache.get(key);\n    }\n    memo.cache = new Map();\n    memo.clear = () => memo.cache.clear();\n    memo.has = (...args) => {\n        const key = hashFn(...args);\n        return key === undefined ? false : memo.cache.has(key);\n    };\n    return memo;\n}\n/**\n * Default arguments hash function.\n * Supports only 0-1 arguments with a primitive type.\n */\nexport function defaultArgsHashFn(...args) {\n    if (args.length === 0)\n        return null;\n    if (args.length > 1)\n        return;\n    if (typeof args[0] !== 'string' && typeof args[0] !== 'number' && typeof args[0] !== 'boolean')\n        return;\n    return String(args[0]);\n}\n","/** Checks that passed value is object, but not a callable-object (function) */\nexport const isObject = (obj) => !!obj && typeof obj === 'object';\n/** Checks that passed value is an object or function */\nexport const isObjectLike = (obj) => isObject(obj) || typeof obj === 'function';\n/** Checks if the passed value is primitive */\nexport const isPrimitive = (obj) => obj === null ||\n    typeof obj === 'undefined' ||\n    typeof obj === 'string' ||\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'symbol';\n/** Checks that passed object is prototype of some class */\nexport const isPrototype = (obj) => Object.hasOwnProperty.call(obj, 'constructor');\n/** Checks that passed object is array-like */\nexport const isArrayLike = (value) => {\n    if (!value || typeof value !== 'object')\n        return false;\n    if (Array.isArray(value))\n        return true;\n    if (typeof value.length !== 'number' || value.length < 0)\n        return false;\n    return !value.length || Object.hasOwnProperty.call(value, value.length - 1);\n};\n/** Deep object compare */\nexport function deepCompare(obj1, obj2) {\n    if (Object.is(obj1, obj2))\n        return true;\n    if (typeof obj1 !== typeof obj2)\n        return false;\n    if (isObject(obj1) && isObject(obj2)) {\n        const keys1 = Object.keys(obj1);\n        const keys2 = Object.keys(obj2);\n        if (keys1.length !== keys2.length)\n            return false;\n        return !keys1.some((key) => !deepCompare(obj1[key], obj2[key]));\n    }\n    return false;\n}\n/** Find the closest property descriptor */\nexport function getPropertyDescriptor(o, prop) {\n    let proto = o;\n    while (proto) {\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\n        if (desc)\n            return desc;\n        proto = Object.getPrototypeOf(proto);\n    }\n}\n/** @returns first defined param */\nexport function defined(...params) {\n    for (const param of params) {\n        if (param !== undefined)\n            return param;\n    }\n}\n/** Makes a plain copy of obj with properties satisfying the predicate\n * If no predicate provided copies all own properties */\nexport function copy(obj, predicate = () => true) {\n    const result = Object.assign({}, obj || {});\n    Object.keys(result).forEach((key) => {\n        (!predicate(key, result[key])) && delete result[key];\n    });\n    return result;\n}\n/** Makes a flat copy without undefined keys */\nexport function copyDefinedKeys(obj) {\n    return copy(obj || {}, (key, value) => value !== void 0);\n}\n/** Omit copying provided properties from object */\nexport function omit(obj, keys) {\n    return copy(obj, key => !keys.includes(key));\n}\n/**\n * Set object property using \"path\" key\n *\n * @param target - object\n * @param path - key path, use '.' as delimiter\n * @param value - value of property\n */\nexport const set = (target, path, value) => {\n    const parts = (path || '').split('.');\n    const depth = parts.length - 1;\n    parts.reduce((cur, key, index) => {\n        if (index === depth)\n            return cur[key] = value;\n        return cur[key] = isObjectLike(cur[key]) ? cur[key] : {};\n    }, target);\n};\n/**\n * Gets object property using \"path\" key\n * Creates empty object if sub-key value is not presented.\n *\n * @param data - object\n * @param path - key path, use '.' as delimiter\n * @param defaultValue - default\n */\nexport const get = (data, path, defaultValue) => {\n    const parts = (path || '').split('.');\n    const result = parts.reduce((curr, key) => {\n        if (isObjectLike(curr))\n            return curr[key];\n        return undefined;\n    }, data);\n    return typeof result === 'undefined' ? defaultValue : result;\n};\nexport function deepMerge(...objects) {\n    return objects.reduce((res, obj, index) => {\n        if (index === 0 && Array.isArray(obj))\n            res = [];\n        isObject(obj) && Object.keys(obj).forEach((key) => {\n            const resultVal = res[key];\n            const objectVal = obj[key];\n            let mergeResult = objectVal;\n            if (isObject(objectVal)) {\n                if (typeof resultVal === 'undefined')\n                    mergeResult = deepMerge(objectVal);\n                else if (isObject(resultVal))\n                    mergeResult = deepMerge(resultVal, objectVal);\n            }\n            res[key] = mergeResult;\n        });\n        return res;\n    }, {});\n}\n","const ns = window || global;\nconst sequences = ns.__esl_sequences__ || new Map();\nns.__esl_sequences__ = sequences;\n/** Create and return sequential id */\nexport const sequentialUID = (name, prefix = name) => {\n    const uid = (sequences.get(name) || 0) + 1;\n    sequences.set(name, uid);\n    return prefix + uid;\n};\n/** Return random unique identifier */\nexport const randUID = (prefix = '') => {\n    const time = Date.now().toString(32);\n    const rand = Math.round(Math.random() * 1024 * 1024).toString(32);\n    return prefix + time + '-' + rand;\n};\n/**\n * Generate unique id\n * @deprecated Alias for {@link randUID}\n */\nexport const generateUId = randUID;\n","export * from './sidebar/sidebar';\r\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nimport { prop, bind, ready, ESLToggleable, ESLMediaQuery } from '@exadel/esl';\r\nimport { attr } from '@exadel/esl/modules/esl-base-element/core';\r\nexport class ESLDemoSidebar extends ESLToggleable {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.closeOnEsc = true;\r\n        this.closeOnOutsideAction = true;\r\n        this.submenus = '.sidebar-nav-secondary';\r\n        this.activeMenuAttr = 'data-open';\r\n    }\r\n    get $submenus() {\r\n        return Array.from(this.querySelectorAll(this.submenus));\r\n    }\r\n    connectedCallback() {\r\n        super.connectedCallback();\r\n        ESLMediaQuery.for('@+MD').addListener(this.onBreakpointChange);\r\n    }\r\n    disconnectedCallback() {\r\n        super.disconnectedCallback();\r\n        ESLMediaQuery.for('@+MD').removeListener(this.onBreakpointChange);\r\n    }\r\n    storeState() {\r\n        this.open ? localStorage.removeItem('sidebar-collapsed') : localStorage.setItem('sidebar-collapsed', 'true');\r\n    }\r\n    setInitialState() {\r\n        const isDesktop = ESLMediaQuery.for('@+MD').matches;\r\n        const isStoredOpen = !localStorage.getItem('sidebar-collapsed');\r\n        this.toggle(isDesktop && isStoredOpen, { force: true, initiator: 'init', immediate: true });\r\n    }\r\n    collapseAll() {\r\n        this.$submenus.forEach((menu) => menu.hide({ activator: this }));\r\n    }\r\n    expandActive(noCollapse = false) {\r\n        this.$submenus\r\n            .filter((menu) => menu.hasAttribute('data-open'))\r\n            .forEach((menu) => menu.show({ noCollapse, activator: this }));\r\n    }\r\n    updateA11y() {\r\n        const targetEl = this.$a11yTarget;\r\n        if (!targetEl)\r\n            return;\r\n        targetEl.setAttribute('aria-expanded', String(this.open));\r\n    }\r\n    onShow(params) {\r\n        this._animation = !params.immediate;\r\n        super.onShow(params);\r\n        this.expandActive(params.initiator === 'init');\r\n        if (params.activator && params.activator.hasAttribute('data-store')) {\r\n            this.storeState();\r\n        }\r\n    }\r\n    onHide(params) {\r\n        this._animation = !params.immediate;\r\n        super.onHide(params);\r\n        this.collapseAll();\r\n        if (params.activator && params.activator.hasAttribute('data-store')) {\r\n            this.storeState();\r\n        }\r\n    }\r\n    onBreakpointChange() {\r\n        const isDesktop = ESLMediaQuery.for('@+MD').matches;\r\n        const isStoredOpen = !localStorage.getItem('sidebar-collapsed');\r\n        this.toggle(isDesktop && isStoredOpen, { force: true, initiator: 'bpchange', immediate: !isDesktop });\r\n    }\r\n    _onOutsideAction(e) {\r\n        if (ESLMediaQuery.for('@+MD').matches)\r\n            return;\r\n        super._onOutsideAction(e);\r\n    }\r\n}\r\nESLDemoSidebar.is = 'esl-d-sidebar';\r\n__decorate([\r\n    prop()\r\n], ESLDemoSidebar.prototype, \"closeOnEsc\", void 0);\r\n__decorate([\r\n    prop()\r\n], ESLDemoSidebar.prototype, \"closeOnOutsideAction\", void 0);\r\n__decorate([\r\n    prop()\r\n], ESLDemoSidebar.prototype, \"submenus\", void 0);\r\n__decorate([\r\n    prop()\r\n], ESLDemoSidebar.prototype, \"activeMenuAttr\", void 0);\r\n__decorate([\r\n    attr({ name: 'animation' })\r\n], ESLDemoSidebar.prototype, \"_animation\", void 0);\r\n__decorate([\r\n    ready\r\n], ESLDemoSidebar.prototype, \"connectedCallback\", null);\r\n__decorate([\r\n    bind\r\n], ESLDemoSidebar.prototype, \"onBreakpointChange\", null);\r\n__decorate([\r\n    bind\r\n], ESLDemoSidebar.prototype, \"_onOutsideAction\", null);\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\r\n  ESLTabs,\r\n  ESLTab,\r\n  ESLPopup,\r\n  ESLPanel,\r\n  ESLPanelGroup,\r\n  ESLTrigger,\r\n  ESLScrollbar,\r\n  ESLAlert,\r\n  ESLToggleableDispatcher,\r\n} from '@exadel/esl';\r\nimport { ESLDemoSidebar } from './navigation/navigation';\r\n\r\nESLDemoSidebar.register();\r\n\r\nESLTabs.register();\r\nESLTab.register();\r\n\r\nESLToggleableDispatcher.init();\r\nESLPopup.register();\r\n\r\nESLPanelGroup.register();\r\nESLPanel.register();\r\n\r\nESLTrigger.register();\r\n\r\nESLScrollbar.register();\r\n\r\nESLAlert.init({\r\n  closeOnOutsideAction: true\r\n});\r\n"],"names":[],"sourceRoot":""}